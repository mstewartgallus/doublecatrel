% Formatting
\documentclass[twocolumn]{scrartcl}

%% Fixers
\usepackage{fontspec}
\usepackage{realscripts}
\usepackage{xunicode}
\usepackage{polyglossia}

\usepackage[]{microtype}
\usepackage[top=0.7in, bottom=0.7in, left=0.7in, right=0.7in]{geometry}
\usepackage[english]{isodate}

% Packages
\usepackage{lastpage}
\usepackage{scrlayer-scrpage}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bussproofs}
\usepackage{stmaryrd}

\usepackage{tikz}
\usepackage{tikz-cd}

%Load Last Fixers

% Settings

\setdefaultlanguage{english}
\setotherlanguage{latin}

\setmainfont{Latin Modern Roman}[Ligatures=TeX,Fractions=On]
\setsansfont{Latin Modern Sans}[Ligatures=TeX,Fractions=On]
\setmonofont{Latin Modern Mono}[Ligatures=TeX,Fractions=On]

%% \hypersetup{bookmarksopen=true,colorlinks=true,allcolors=blue}

%% \setlength{\mathindent}{0pt}

\newcommand{\Rel}{\textbf{Rel}}
\newcommand{\Set}{\textbf{Set}}
\newcommand{\lk}{\(\bar{\lambda}\mu\tilde{\mu}\,\)}

\newcommand{\name}[1]{\LeftLabel{\fbox{#1}}}

\newcommand{\taut}{\AxiomC{\(\top\)}}
\newcommand{\bnfdef}{\mathrel{::=}}

\newcommand{\step}{\mathrel{\rightsquigarrow}}
\newcommand{\with}{\;}
\newcommand{\sat}{\mathbin{\otimes}}


\newcommand{\axiom}[2]{\fbox{#1}~#2}
\newcommand{\judge}[3]{
  \AxiomC{\(#2\)}
  \name{#1}
  \UnaryInfC{\(#3\)}
  \DisplayProof
}
\newcommand{\bijudge}[4]{
  \AxiomC{#2}
  \AxiomC{#3}
  \name{#1}
  \BinaryInfC{#4}
  \DisplayProof
}
\newcommand{\trijudge}[5]{
  \AxiomC{#2}
  \AxiomC{#3}
  \AxiomC{#4}
  \name{#1}
  \TrinaryInfC{#5}
  \DisplayProof
}

\DeclareMathOperator{\val}{\textbf{v}}
\DeclareMathOperator{\prd}{\textbf{p}}

\DeclareMathOperator{\unit}{\top}
\DeclareMathOperator{\mt}{\emptyset}
\DeclareMathOperator{\coin}{\textbf{!}}
\DeclareMathOperator{\fst}{\pi_1}
\DeclareMathOperator{\snd}{\pi_2}

\DeclareMathOperator{\success}{\textbf{success}}
\newcommand{\pass}{\mathbin{\gg}}

\DeclareMathOperator{\absurd}{\textbf{abort}}
\DeclareMathOperator{\inl}{\textbf{i}_1}
\DeclareMathOperator{\inr}{\textbf{i}_2}

\DeclareMathOperator{\false}{\textbf{fail}}
\DeclareMathOperator{\lft}{\textbf{l}}
\DeclareMathOperator{\rgt}{\textbf{r}}

\DeclareMathOperator{\type}{\Box}
\DeclareMathOperator{\prop}{*}

\DeclareMathOperator{\head}{\textbf{h}}
\DeclareMathOperator{\tail}{\textbf{t}}

\newcommand{\Forall}{\Pi}

\newcommand{\update}{\mathbin{:=}}

\DeclareMathOperator{\case}{\textbf{m}}

\begin{document}

I wanted to try figuring out a sort of internal language corresponding
to the double category \Rel.

You have a calculus of ``values'' corresponding to the \Set edge of
\Rel and a sort of relational calculus of ``predicates'' corresponding
to the other edge. Squares ought to correspond to judgements stating a
value satisfies a predicate.

The language of ``values'' handling Cartesian product of sets has
product types (in category theory terms is Cartesian.)

The language of ``predicates'' which we call the ``context calculus''
ought to be more complicated. \Rel is a closed monoidal category over
Cartesian product of sets.  One has an isomorphism \( \Rel(A, B
\otimes C) \sim \Rel (A \otimes B, C) \).  So some sort of linear type
theory is required.

The language of ``squares'' is confusing. It ought to correspond to
control expressions in \lk.

This is the core framework.  I've been thinking about further
extensions but I want to see how far I can get characterizing
\Rel with as few language features as possible.  Later on I
give a few possible extensions.

\section*{Core Calculi}

\begin{description}[nosep]
\item[Types] \hfill \( t \bnfdef \unit \mid t \times t \)
\item[Values] \hfill \( v \bnfdef x \mid \coin \mid \fst(v) \mid \snd(v) \mid v , v \)
\item[Predicates] \hfill \( p \bnfdef x_t \mid \success \mid p \pass p \mid p \, p \mid \forall (x \colon t) . p \)
\item[Environment] \hfill \( \Gamma \bnfdef \cdot \mid \Gamma , \, x \colon t  \)
\item[Control Environment] \hfill \( \Theta \bnfdef \cdot \mid \Theta , \, x \mid v  \)
\end{description}

The core context calculus is the linear lambda calculus with a few
symbol changes.  The core value calculus has only product types.

I'm not really sure small steps semantics make sense with respect to
the context calculus but the value calculus corresponding to \Set
ought to have simple deterministic semantics.

\subsubsection*{Context Calculus}

The context calculus has a linear variable rule.  As a hack to make
mechanization easier linear variables are explicitly indexed by their
types and variable binding is more imperative.

\begin{flushleft}

\axiom{V}
      {\(\cdot , \, x \colon t \vdash x_t \colon t\)}

\axiom{\(\unit\)I}
      {\(\cdot \vdash \success \colon \unit\)}

\bijudge{\(\unit\)E}
        {\(\Gamma \vdash p_0 \colon \unit \)}
        {\(\Delta \vdash p_1 \colon t \)}
        {\(\Gamma, \, \Delta \vdash p_0 \pass p_1 \colon t\)}
  
\bijudge{\(\times\)I}
        {\( x \colon t_0 \in \Gamma \)}
        {\( \Gamma \vdash p \colon t_1 \)}
        {\( \Gamma \setminus x \vdash \forall (x \colon t_0). p \colon t_0 \times t_1 \)}

\bijudge{\(\times\)E}
        {\(\Gamma \vdash p_0 \colon t_0 \times t_1\)}
        {\(\Delta \vdash p_1 \colon t_1\)}
        {\(\Gamma, \, \Delta \vdash p_0 \, p_1 \colon t_1\)}

\axiom{\(\unit\)R}
      {\( \success \pass p \step p \)}

\axiom{\(\times\)R}
      {\( ( \forall (x \colon t ). p_0) \, p_1 \step [x_t \update p_1] p_0 \)}

\end{flushleft}


\subsubsection*{Value Calculus}

\begin{flushleft}

\judge{V}
      {x \colon t \in \Gamma}
      {\Gamma \vdash x \colon t}

\axiom{\(\unit\)I}
      {\(\Gamma \vdash \coin \colon \unit \)}

{\judge{\(\times\text{E}_1\)}
       {\Gamma \vdash v \colon t_0 \times t_1}
       {\Gamma \vdash \fst(v) \colon t_0}
\hfill
\judge{\(\times\text{E}_2\)}
      {\Gamma \vdash v \colon t_0 \times t_1}
      {\Gamma \vdash \snd(v) \colon t_1 }
}

\bijudge{\(\times\)I}
        {\(\Gamma \vdash v_0 \colon t_0\)}
        {\(\Gamma \vdash v_1 \colon t_1\)}
        {\(\Gamma \vdash v_0, v_1 \colon t_0 \times t_1 \)}

{\axiom{\(\times\text{R}_1\)}
       {\(\fst (v_0 , v_1 ) \step v_0 \)}
\hfill
\axiom{\(\times\text{R}_2\)}
      {\(\snd (v_0 , v_1 ) \step v_1 \)}
}

\end{flushleft}

\subsubsection*{Control Calculus}

\begin{flushleft}

\axiom{V}
      {\(\cdot , \, x_t \sat v  \vdash  x_t \sat v \)}

\bijudge{vR}
        {\(v_0 \step v_1\)}
        {\(\Theta \vdash p \sat v_0  \)}
        {\(\Theta \vdash p \sat v_1  \)}

\bijudge{pR}
        {\(p_0 \step p_1\)}
        {\(\Theta \vdash  p_0 \sat v  \)}
        {\(\Theta \vdash  p_1 \sat v  \)}

\axiom{\(\unit\)I}
      {\(\Theta \vdash  \coin \sat \success \)}

\judge{\(\times\)I}
      { \Theta , \,  x_t \sat v_0  \vdash  p \sat v_1 }
      { \Theta \vdash  \forall (x \colon t ). p \sat  v_0 , v_1 }

\end{flushleft}

\section*{Examples}

Pattern matching on equality

\begin{prooftree}

  \taut
  \RightLabel{\scriptsize{(V)}}
  \UnaryInfC{\( \Theta , \,  x_t \sat v  \vdash  x_t \sat v  \)}
  \RightLabel{\scriptsize{(\(\times\)I)}}
  \UnaryInfC{\( \Theta \vdash  \forall (x \colon t). x_t  \sat v , v \)}

\end{prooftree}

Transposition

\( \forall (p \colon t \times t \times \unit) (x \colon t) (y \colon t). p_{(t \times t \times \unit)} \, y_t \, x_t \)

\section*{Disjoint Unions}

Disjoint unions in \Set become Cartesian product/coproduct in \Rel.
It might make sense to use different notations for coproduct in \Rel.

I decided against rules for mapping from \Set to \Rel because I wanted
to see how far \Rel could go on its own and also wanted to see if
these could be defined later.

I have a hunch it is proper for the combination of product/coproduct
to introduce nondeterminism in the operational semantics but I need to
think more about the issue.

As a technical hack \(\false\) is explicitly indexed by the environment it ignores.
This hack also requires inferring the environment in certain reduction rules.

\begin{description}[nosep]
\item[Types] \hfill \( t \bnfdef \ldots \mid \mt \mid t + t \)
\item[Values] \hfill \( v \bnfdef \ldots \mid \absurd_t(v) \mid \inl_t(v) \mid \inr_t(v) \mid
  \case(v, x. v, x. v)
  \)
\item[Predicates] \hfill \( p \bnfdef \ldots \mid
  \absurd_t(p) \mid \inl_t(p) \mid \inr_t(p) \mid \case(v, x. v, x. v) \mid
  \false_\Gamma \mid \lft(p) \mid \rgt(p) \mid p ; p \)
\end{description}

\subsubsection*{Value Calculus}

\begin{flushleft}

\judge{\(\mt\)E}
        {\Gamma \vdash v \colon \mt}
        {\Gamma \vdash \absurd_t(v) \colon t}

{\judge{\(+\text{I}_1\)}
       {\Gamma \vdash v \colon t_0}
       {\Gamma \vdash \inl_{t_1}(v) \colon t_0 + t_1}
\hfill
\judge{\(+\text{I}_2\)}
      {\Gamma \vdash v \colon t_1}
      {\Gamma \vdash \inr_{t_0}(v) \colon t_0 + t_1}
}

\trijudge{\(+\)E}
         {\( \Gamma \vdash v_0 \colon t_0 + t_1 \)}
         {\( \Gamma , \, x_0 \colon t_0 \vdash v_1 \colon t_2 \)}
         {\( \Gamma , \, x_1 \colon t_1 \vdash v_1 \colon t_2 \)}
         {\(
  \Gamma \vdash
  \case(v_0, x_0. v_1, x_1. v_2)
  \colon t_2 
\)}

\axiom{\(+\text{R}_1\)}
      {\(
  \case(\inl_t(v_0), x_0. v_1, x_1. v_2) \step [x_0 \update v_0] v_1
  \)}

\axiom{\(+\text{R}_2\)}
      {\(
  \case(\inr_t(v_0), x_0. v_1, x_1. v_2) \step [x_1 \update v_0] v_2
  \)}

\end{flushleft}


\subsubsection*{Context Calculus}

\begin{flushleft}

\judge{\(\mt\text{E}^\text{T}\)}
      {\Gamma \vdash p \colon \mt}
      {\Gamma \vdash \absurd_t(v) \colon t}

{\judge{\(+\text{I}^\text{T}_1\)}
       {\Gamma \vdash p \colon t_0}
       {\Gamma \vdash \inl_{t_1}(v) \colon t_0 + t_1}
\hfill
\judge{\(+\text{I}^\text{T}_2\)}
      {\Gamma \vdash p \colon t_1}
      {\Gamma \vdash \inr_{t_0}(v) \colon t_0 + t_1}
}

\trijudge{\(+\text{E}^\text{T}\)}
        {\( \Gamma \vdash p_0 \colon t_0 + t_1 \)}
        {\( \Gamma , \, x_0 \colon t_0 \vdash p_1 \colon t_2 \)}
        {\( \Gamma , \, x_1 \colon t_1 \vdash p_1 \colon t_2 \)}
        {\(
  \Gamma \vdash
  \case(p_0, x_0. p_1, x_1. p_2)
  \colon t_2 
\)}

\axiom{\(\mt\)I}
      {\( \Gamma \vdash \false_\Gamma \colon \mt \)}

{\judge{\(+\text{E}_1\)}
       {\Gamma \vdash p \colon t_0 + t_1}
       {\Gamma \vdash \lft(p) \colon t_0}
\hfill
\judge{\(+\text{E}_2\)}
      {\Gamma \vdash p \colon t_0 + t_1}
      {\Gamma \vdash \rgt(p) \colon t_1)}
}

\bijudge{\(+\)I}
        {\( \Gamma \vdash p_0 \colon t_0 \)}
        {\( \Gamma \vdash p_1 \colon t_1 \)}
        {\( \Gamma \vdash p_0 ; p_1 \colon t_0 + t_1 \)}

\axiom{\(+\text{R}^\text{T}_1\)}
      {\(
  \case(\inl_t(p_0), x_0. p_1, x_1. p_2) \step [x_0 \update p_0] p_1
  \)}

\axiom{\(+\text{R}^\text{T}_2\)}
      {\(
  \case(\inr_t(p_0), x_0. p_1, x_1. p_2) \step [x_1 \update p_0] p_2
  \)}

{\axiom{\(+\text{R}_1\)}
  {\( \lft(p_0 ; p_1) \step p_0 \)}
\hfill
  \axiom{\(+\text{R}_2\)}
      {\( \rgt(p_0 ; p_1) \step p_1 \)}
}

{
\axiom{\(+\text{R}\text{R}^\text{T}_1\)}
      {\( \lft(\inl_t(p)) \step p \)}
\hfill
\axiom{\(+\text{R}\text{R}^\text{T}_2\)}
      {\( \rgt(\inr_t(p)) \step p \)}
}

{
\judge{\(+\text{R}\text{R}^\text{T}_3\)}
      {\Gamma \vdash p \colon t}
      {\lft(\inr_t(p)) \step \absurd_t(\false_\Gamma)}
\hfill
\judge{\(+\text{R}\text{R}^\text{T}_4\)}
      {\Gamma \vdash p \colon t}
      {\rgt(\inl_t(p)) \step \absurd_t(\false_\Gamma)}
}


\axiom{\(+\text{R}^\text{T}\text{R}_1\)}
      {\(
  \case(p_0 ; p_1, x_0. p_2, x_1. p_3) \step [x_0 := p_0] p_2
  \)}

\axiom{\(+\text{R}^\text{T}\text{R}_2\)}
      {\(
  \case(p_0 ; p_1, x_0. p_2, x_1. p_3) \step [x_1 := p_1] p_3
  \)}

\end{flushleft}


\subsubsection*{Control Calculus}

\begin{flushleft}

{
\judge{\(+\text{I}_1\)}
      {\Theta \vdash  p_0 \sat v }
      {\Theta \vdash  p_0 ; p_1 \sat \inl_t(v) }
\hfill
\judge{\(+\text{I}_2\)}
      {\Theta \vdash  p_1 \sat v }
      {\Theta \vdash  p_0 ; p_1 \sat \inr_t(v)  }
}

\judge{\(\mt\)I}
      {\Theta \vdash  p \sat \absurd_t(v) }
      {\Theta \vdash  \false_\Gamma \sat v }

\end{flushleft}

\section*{Dependent Sums}

If product of sets becomes an internal hom in the predicate calculus
then dependent sums ought to become a little like \(\Pi\) types.  So
the predicate calculus effectively becomes like a linear System-F.

Some things become awkward to interpret here though.

I also really can't figure out unpacking. It's messy if you don't want
full dependent types.

\begin{description}[nosep]
\item[Types] \hfill  \( t \bnfdef \ldots \mid x \mid \prop \mid \head(v) \mid \Sigma (x \colon \prop). t \)
\item[Values] \hfill  \( v \bnfdef \ldots \mid \tail(v) \mid \langle x \update t , v \rangle \)
\item[Predicates] \hfill  \( p \bnfdef \ldots \mid p \, t \mid \Forall (x \colon \prop). p \)
\item[Control Environment] \hfill  \( \Theta \bnfdef \ldots \mid \Theta , \, x \sat t \)
\end{description}

Not really good at the typing judgements for dependent sum types.


\subsubsection*{Values}

\begin{flushleft}
  
\judge{\(\Sigma\text{E}_1\)}
      {\Gamma \vdash v \colon \Sigma (x \colon \prop). t}
      {\Gamma \vdash \head(v) \colon \prop}

\judge{\(\Sigma\text{E}_2\)}
      {\Gamma \vdash v \colon \Sigma (x \colon \prop). t}
      {\Gamma \vdash \tail(v) \colon [x \update \head(v)] t}


\bijudge{\(\Sigma\)I}
        {\( \Gamma \vdash t_0 \colon \prop  \)}
        {\( \Gamma , \, x \colon \prop \vdash v \colon t_1 \)}
        {\(
  \Gamma \vdash \langle x \update t_0 , v \rangle \colon \Sigma (x \colon \prop). t_0  \)}


{\axiom{\(\Sigma\text{S}_1\)}
  {\( \head(\langle x \update t , v \rangle) \step t \)}
\hfill
\axiom{\(\Sigma\text{S}_2\)}
      {\( \tail( \langle x \update t , v \rangle) \step [x \update t] v \)}
}
\end{flushleft}

\subsubsection*{Context Calculus}

\begin{flushleft}

\bijudge{\(\Sigma\)E}
        {\( \Gamma \vdash p \colon \Sigma (x\colon \prop). t_1  \)}
        {\( \Delta \vdash t_0 \colon \prop \)}
        {\( \Gamma, \, \Delta \vdash p_0 \, t_0 \colon [x \update t_0] t_1 \)}

\judge{\(\Sigma\)I}
      {\Gamma , \, x \colon \prop \vdash p \colon t}
      {\Gamma \vdash \Forall (x \colon \prop). p \colon \Sigma (x \colon \prop). t}

\axiom{\(\Sigma\)R}
      {\( ( \Forall (x \colon \prop). p) \, t \step [x \update t] p \)}

\end{flushleft}

\subsubsection*{Control Calculus}

I can't figure out satisfaction at all.

\begin{flushleft}
\judge{\(\Sigma\)I}
      {\Theta , \,  x \sat t  \vdash  p \sat v }
      {\Theta \vdash  \Forall (x \colon \prop). p \sat \langle x \update t , v \rangle 
  }
\end{flushleft}

\section*{Categorical Semantics}
%% Useful as hell, cite somewhere ?
%% https://tikzcd.yichuanshen.de/

The intent is to create calculi encoding the core features of the
double category \Rel.

If this is successful then terms and types ought to map to \Rel as
follows.

\begin{center}
  \begin{tikzcd}
    \unit \arrow{dd}[']{\Theta_p} \arrow{rr}{\Theta_v} & {} \arrow[Rightarrow]{dd}{\Theta_p , \Theta_v \vdash p \sat v} & \times_{x\colon t \in \Gamma_v} t \arrow{dd}{v} \\
    &                               &                      \\
    \times_{x\colon t \in \Gamma_p} t \arrow{rr}[']{p}                           & {}                            & t                   
  \end{tikzcd}
\end{center}

I have no idea about universe issues and such. Dependent sum is probably wrong.

Really need to think about denotation again.

\begin{multline*}
  \\
  \llbracket \unit \rrbracket = \{ \emptyset \} \\
  \llbracket t_0 \times t_1 \rrbracket = \llbracket t_0 \rrbracket \times \llbracket t_1 \rrbracket \\
  \llbracket \mt \rrbracket = \emptyset \\
  \llbracket t_0 + t_1 \rrbracket = \llbracket t_0 \rrbracket \sqcup \llbracket t_1 \rrbracket \\
  \llbracket \Sigma (x \colon \prop). t(x) \rrbracket = \bigsqcup_{ x \in \prop} \llbracket t(x) \rrbracket \\
  \\
  \llbracket \coin \rrbracket = \emptyset \\
  \llbracket ( v_0 , v_1 ) \rrbracket = ( \llbracket v_0 \rrbracket , \llbracket v_1 \rrbracket ) \\
  \\
  \llbracket \success \rrbracket(y) = \top \\
  \llbracket p_0 p_1 \rrbracket(y) = \exists z,  \llbracket p_1 \rrbracket (z) \wedge \llbracket p_0 \rrbracket (z, y)\\
  \llbracket \forall (x \colon t). p \rrbracket(\langle x, y \rangle) = \llbracket p(x) \rrbracket (y)  \\
\end{multline*}

\section*{Synthetic Category Theory}

A category is a monad in Span.  Once this system has been generalized
to Span we can define monads internal to Span.

This is not fully internal but a simple approach to defining an
equivalence relation might be something like:

\begin{flushleft}

\axiom{object}
      {\( \cdot \vdash O \colon \prop \)}

\axiom{arrow}
      {\( \cdot \vdash R \colon O \times O \)}

\judge{refl}
      {\cdot \vdash o \colon O}
      {\cdot \vdash  R \sat o, o }

\bijudge{trans}
       {\( \cdot \vdash o_0, o_1 \colon O \times O \)} 
      {\( \cdot \vdash  \forall (x\colon O). R \, (R \, x)  \sat o_0, o_1 \)}
      {\( \cdot \vdash  R \sat o_0, o_1  \)}

\bijudge{sym}
      {\( \cdot \vdash o_1, o_0 \colon O \times O \)}
      {\( \cdot \vdash  R \sat o_0, o_1  \)}
      {\( \cdot \vdash  R \sat o_1, o_0  \)}
      
\end{flushleft}

Generalizing to a constructive interpretation in terms of spans and
groupoids is future work.

\section*{The Future?}

Satisifies judgments correspond to thin squares. Moving to more
general categories such as \textbf{Span} or \textbf{Prof} or
\textbf{Vect} for matrix math requires an interpretation of squares
carrying constructive content.

\end{document}
