% Formatting
\documentclass[twocolumn]{scrartcl}

%% Fixers
\usepackage{fontspec}
\usepackage{realscripts}
\usepackage{xunicode}
\usepackage{polyglossia}

\usepackage[]{microtype}
\usepackage[top=0.7in, bottom=0.75in, left=0.75in, right=0.7in]{geometry}
\usepackage[english]{isodate}

% Packages
\usepackage{lastpage}
\usepackage{scrlayer-scrpage}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{bussproofs}

\usepackage{tikz}
\usepackage{tikz-cd}

%Load Last Fixers

% Settings

\setdefaultlanguage{english}
\setotherlanguage{latin}

\setmainfont{Latin Modern Roman}[Ligatures=TeX,Fractions=On]
\setsansfont{Latin Modern Sans}[Ligatures=TeX,Fractions=On]
\setmonofont{Latin Modern Mono}[Ligatures=TeX,Fractions=On]

%% \hypersetup{bookmarksopen=true,colorlinks=true,allcolors=blue}

%% \setlength{\mathindent}{0pt}

\newcommand{\Rel}{\textbf{Rel}}
\newcommand{\Set}{\textbf{Set}}
\newcommand{\lk}{\(\bar{\lambda}\mu\tilde{\mu}\,\)}

\newcommand{\name}[1]{\LeftLabel{\fbox{#1}}}

\newcommand{\taut}{\AxiomC{\(\top\)}}


\newcommand{\bnfdef}{\mathrel{::=}}

\newcommand{\step}{\mathbin{\longrightarrow}}
\newcommand{\with}{\;}

\DeclareMathOperator{\val}{\textbf{v}}
\DeclareMathOperator{\prd}{\textbf{p}}

\DeclareMathOperator{\unit}{\top}
\DeclareMathOperator{\mt}{\emptyset}
\DeclareMathOperator{\coin}{\textbf{tt}}
\DeclareMathOperator{\fst}{\pi_1}
\DeclareMathOperator{\snd}{\pi_2}

\DeclareMathOperator{\success}{\textbf{success}}
\newcommand{\pass}{;}

\DeclareMathOperator{\absurd}{\textbf{absrd}}
\DeclareMathOperator{\inl}{\textbf{i}_1}
\DeclareMathOperator{\inr}{\textbf{i}_2}

\DeclareMathOperator{\false}{\textbf{fls}}
\DeclareMathOperator{\lft}{\textbf{l}}
\DeclareMathOperator{\rgt}{\textbf{r}}

\DeclareMathOperator{\type}{\Box}
\DeclareMathOperator{\prop}{*}

\DeclareMathOperator{\head}{\textbf{h}}
\DeclareMathOperator{\tail}{\textbf{t}}

\newcommand{\Forall}{\Pi}

\newcommand{\update}{\mathbin{:=}}

\DeclareMathOperator{\case}{\textbf{m}}

\begin{document}

I wanted to try figuring out a sort of internal language corresponding
to the double category \Rel.

You have a calculus of ``values'' corresponding to the \Set edge of
\Rel and a sort of relational calculus of ``predicates'' corresponding
to the other edge. Squares ought to correspond to judgements stating a
value satisfies a predicate.

The language of ``values'' handling Cartesian product of sets has
product types (in category theory terms is Cartesian.)

The language of ``predicates'' ought to be more complicated. \Rel
is a closed monoidal category over Cartesian product of sets.  One has
an isomorphism \( \Rel(A, B \otimes C) \sim \Rel (A \otimes B, C) \).
So some sort of linear type theory is required.

This is the core framework.  I've been thinking about further
extensions but I want to see how far I can get characterizing
\(\Rel\) with as few language features as possible.  Later on I
give a few possible extensions.

\section*{Core Calculi}

\begin{description}[nosep]
\item[Types] \hfill \( t \bnfdef \unit \mid t \times t \)
\item[Values] \hfill \( v \bnfdef x \mid \coin \mid \fst(v) \mid \snd(v) \mid ( v , v ) \)
\item[Predicates] \hfill \( p \bnfdef x \mid \success \mid p \pass p \mid p \, p \mid \forall (x \colon t) . p \)
\item[Environment] \hfill \( \Gamma \bnfdef \cdot \mid \Gamma , \, x \colon t  \)
\item[Substitutions] \hfill \( \sigma \bnfdef \cdot \mid \sigma , \, v \models x  \)
\end{description}

The core relational calculus is the linear lambda calculus with a few
symbol changes.  The core value calculus has only product types.

I'm not really sure small steps semantics make sense with respect to
the relational calculus but the value calculus corresponding to \Set
ought to have simple deterministic semantics.

\subsubsection*{Relational Calculus}

\begin{flushleft}

\AxiomC{\( x \colon t \in \Gamma \)}
\name{V}
\UnaryInfC{\(\Gamma \vdash x \colon t \)}
\DisplayProof

\taut
\name{\(\unit\)I}
\UnaryInfC{\(\Gamma \vdash \success \colon \unit\)}
\DisplayProof

\AxiomC{\(\Gamma \vdash p_0 \colon \unit \)}
\AxiomC{\(\Delta \vdash p_1 \colon t \)}
\name{\(\unit\)E}
\BinaryInfC{\(\Gamma, \, \Delta \vdash p_0 \pass p_1 \colon t\)}
\DisplayProof
  
\AxiomC{\(\Gamma, x \colon t_0 \vdash p \colon t_1\)}
\name{\(\times\)I}
\UnaryInfC{\(\Gamma \vdash \forall (x \colon t_0). p \colon t_0 \times t_1\)}
\DisplayProof

\AxiomC{\(\Gamma \vdash p_0 \colon t_0 \times t_1\)}
\AxiomC{\(\Delta \vdash p_1 \colon t_1\)}
\name{\(\times\)E}
\BinaryInfC{\(\Gamma, \, \Delta \vdash p_0 p_1 \colon t_1\)}
\DisplayProof

\taut
\name{\(\unit\)R}
\UnaryInfC{\( \success \pass p \step p \)}
\DisplayProof

\taut
\name{\(\times\)R}
\UnaryInfC{\( ( \forall (x \colon t ). p_0) \, p_1 \step [x \update p_1] p_0 \)}
\DisplayProof

\end{flushleft}


\subsubsection*{Value Calculus}

The variable rule is useless here but becomes important in later
extensions.

\begin{flushleft}

\AxiomC{\( x \colon t \in \Gamma \)}
\name{V}
\UnaryInfC{\(\Gamma \vdash x \colon t \)}
\DisplayProof

\taut
\name{\(\unit\)I}
\UnaryInfC{\(\Gamma \vdash \coin \colon \unit \)}
\DisplayProof

{\AxiomC{\(\Gamma \vdash v \colon t_0 \times t_1\)}
\name{\(\times\text{E}_1\)}
\UnaryInfC{\(\Gamma \vdash \fst(v) \colon t_0 \)}
\DisplayProof
\hfill
\AxiomC{\(\Gamma \vdash v \colon t_0 \times t_1\)}
\name{\(\times\text{E}_2\)}
\UnaryInfC{\(\Gamma \vdash \snd(v) \colon t_1 \)}
\DisplayProof
}

\AxiomC{\(\Gamma \vdash v_0 \colon t_0\)}
\AxiomC{\(\Gamma \vdash v_1 \colon t_1\)}
\name{\(\times\)I}
\BinaryInfC{\(\Gamma \vdash (v_0, v_1) \colon t_0 \times t_1 \)}
\DisplayProof

{\taut
\name{\(\times\text{R}_1\)}
\UnaryInfC{\(\fst (v_0 , v_1 ) \step v_0 \)}
\DisplayProof
\hfill
\taut
\name{\(\times\text{R}_2\)}
\UnaryInfC{\(\snd (v_0 , v_1 ) \step v_1 \)}
\DisplayProof
}

\end{flushleft}

\subsubsection*{Satisfaction Judgements}

I need a better symbol here.

\begin{flushleft}

\AxiomC{\(v \models x \in \sigma\)}
\name{VAR-S}
\UnaryInfC{\( v \models x \with [\sigma] \)}
\DisplayProof

\AxiomC{\(v_0 \step v_1\)}
\AxiomC{\(v_0 \models p \with [\sigma]\)}
\name{vR-S}
\BinaryInfC{\( v_1 \models p \with [\sigma] \)}
\DisplayProof

\AxiomC{\(p_0 \step p_1\)}
\AxiomC{\(v \models p_0 \with [\sigma]\)}
\name{pR-S}
\BinaryInfC{\(v \models p_1 \with [\sigma] \)}
\DisplayProof

\taut
\name{\(\unit\)S}
\UnaryInfC{\(
  \coin \models \success \with [\sigma] \)}
\DisplayProof

\AxiomC{\( v_1 \models p \with [ \sigma , \, v_0 \models x] \)}
\name{\(\times\)S}
\UnaryInfC{\(( v_0 , v_1 ) \models \forall (x \colon t ). p \with [\sigma] \)}
\DisplayProof
\end{flushleft}

\section*{Examples}

Pattern matching on equality

\begin{prooftree}

  \taut
  \RightLabel{\scriptsize{(VAR-S)}}
  \UnaryInfC{\( v \models x \with [ \sigma , \, v \models x] \)}
  \RightLabel{\scriptsize{(\(\times\)S)}}
  \UnaryInfC{\( ( v , v ) \models \forall (x \colon t). x \with [\sigma] \)}

\end{prooftree}

Transposition

\(  \forall (p \colon t \times t \times \unit) (x \colon t) (y \colon t). p \, y \, x \)

\section*{Disjoint Unions}

Disjoint unions in set become Cartesian product/coproduct in \Rel.

I am fairly confident in a simple extension to disjoint unions
of sets which are sum types in the value calculus and product types in
the predicate calculus.

\begin{description}[nosep]
\item[Types] \hfill \( t \bnfdef \ldots \mid \mt \mid t + t \)
\item[Values] \hfill \( v \bnfdef \ldots \mid \absurd_t(v) \mid \inl_t(v) \mid \inr_t(v) \mid
  \case(v, x. v, x. v)
  \)
\item[Predicates] \hfill \( p \bnfdef \ldots \mid \false \mid \lft(p) \mid \rgt(p) \mid [ p \mid p ] \)
\end{description}

\subsubsection*{Values}

\begin{flushleft}

\AxiomC{\( \Gamma \vdash v \colon \mt \)}
\name{\(\mt\)E}
\UnaryInfC{\( \Gamma \vdash \absurd_t(v) \colon t \)}
\DisplayProof

{\AxiomC{\( \Gamma \vdash v \colon t_0 \)}
\name{\(+\text{I}_1\)}
\UnaryInfC{\( \Gamma \vdash \inl_{t_1}(v) \colon t_0 + t_1  \)}
\DisplayProof
\hfill
\AxiomC{\( \Gamma \vdash v \colon t_1 \)}
\name{\(+\text{I}_2\)}
\UnaryInfC{\( \Gamma \vdash \inr_{t_0}(v) \colon t_0 + t_1  \)}
\DisplayProof
}

\AxiomC{\( \Gamma \vdash v_0 \colon t_0 + t_1 \)}
\AxiomC{\( \Gamma , \, x_0 \colon t_0 \vdash v_1 \colon t_2 \)}
\AxiomC{\( \Gamma , \, x_1 \colon t_1 \vdash v_1 \colon t_2 \)}
\name{\(+\)E}
\TrinaryInfC{\(
  \Gamma \vdash
  \case(v_0, x_0. v_1, x_1. v_2)
  \colon t_2 
\)}
\DisplayProof

\taut
\name{\(+\text{R}_1\)}
\UnaryInfC{\(
  \case(\inl_t(v_0), x_0. v_1, x_1. v_2) \step [x_0 \update v_0] v_1
  \)}
\DisplayProof

\taut
\name{\(+\text{R}_2\)}
\UnaryInfC{\(
  \case(\inr_t(v_0), x_0. v_1, x_1. v_2) \step [x_1 \update v_0] v_2
  \)}
\DisplayProof

\end{flushleft}


\subsubsection*{Predicates}

\begin{flushleft}

\taut
\name{\(\mt\)I}
\UnaryInfC{\( \Gamma \vdash \false \colon \mt \)}
\DisplayProof

{\AxiomC{\( \Gamma \vdash p \colon t_0 + t_1 \)}
\name{\(+\text{E}_1\)}
\UnaryInfC{\( \Gamma \vdash \lft(p) \colon t_0 \)}
\DisplayProof
\hfill
\AxiomC{\( \Gamma \vdash p \colon t_0 + t_1 \)}
\name{\(+\text{E}_2\)}
\UnaryInfC{\( \Gamma \vdash \rgt(p) \colon t_1 \)}
\DisplayProof
}

\AxiomC{\( \Gamma \vdash p_0 \colon t_0 \)}
\AxiomC{\( \Gamma \vdash p_1 \colon t_1 \)}
\name{\(+\)I}
\BinaryInfC{\( \Gamma \vdash [p_0 \mid p_1] \colon t_0 + t_1 \)}
\DisplayProof

{\taut
\name{\(+\text{R}_1\)}
\UnaryInfC{\( \lft([ p_0 \mid p_1 ]) \step p_0 \)}
\DisplayProof
\hfill
\taut
\name{\(+\text{R}_2\)}
\UnaryInfC{\( \rgt([ p_0 \mid p_1 ]) \step p_1 \)}
\DisplayProof
}
\end{flushleft}


\subsubsection*{Satisfies}

\begin{flushleft}

\AxiomC{\( v \models p_0 \with [\sigma] \)}
\name{\(+\text{S}_1\)}
\UnaryInfC{\( \inl_t(v) \models [ p_0 \mid p_1 ] \with [\sigma] \)}
\DisplayProof

\AxiomC{\( v \models p_1 \with [\sigma] \)}
\name{\(+\text{S}_2\)}
\UnaryInfC{\( \inr_t(v) \models [ p_0 \mid p_1 ] \with [\sigma] \)}
\DisplayProof

\AxiomC{\( \absurd_t(v) \models p \with [\sigma] \)}
\name{\(\mt\)S}
\UnaryInfC{\(  v \models \false \with [\sigma] \)}
\DisplayProof

\end{flushleft}

\section*{Dependent Sums}

If product of sets becomes an internal hom in the predicate calculus
then dependent sums ought to become a little like \(\Pi\) types.  So
the predicate calculus effectively becomes like a linear System-F.

Some things become awkward to interpret here though.

I also really can't figure out unpacking. It's messy if you don't want
full dependent types.

\begin{description}[nosep]
\item[Types] \hfill  \( t \bnfdef \ldots \mid x \mid \prop \mid \head(v) \mid \Sigma (x \colon \prop). t \)
\item[Values] \hfill  \( v \bnfdef \ldots \mid \tail(v) \mid \langle x \update t , v \rangle \)
\item[Predicates] \hfill  \( p \bnfdef \ldots \mid p \, t \mid \Forall (x \colon \prop). p \)
\item[Substitutions] \hfill  \( \sigma \bnfdef \ldots \mid \sigma , \, t \models x \)
\end{description}

Not really good at the typing judgements for dependent sum types.


\subsubsection*{Values}

\begin{flushleft}
  
\AxiomC{\( \Gamma \vdash v \colon \Sigma (x \colon \prop). t \)}
\name{\(\Sigma\text{E}_1\)}
\UnaryInfC{\( \Gamma \vdash \head(v) \colon \prop \)}
\DisplayProof

\AxiomC{\( \Gamma \vdash v \colon \Sigma (x \colon \prop). t  \)}
\name{\(\Sigma\text{E}_2\)}
\UnaryInfC{\(
  \Gamma \vdash \tail(v) \colon [x \update \head(v)] t \)}
\DisplayProof


\AxiomC{\( \Gamma \vdash t_0 \colon \prop  \)}
\AxiomC{\( \Gamma , \, x \colon \prop \vdash v \colon t_1 \)}
\name{\(\Sigma\)I}
\BinaryInfC{\(
  \Gamma \vdash \langle x \update t_0 , v \rangle \colon \Sigma (x \colon \prop). t_0  \)}
\DisplayProof


{\taut
\name{\(\Sigma\text{S}_1\)}
\UnaryInfC{\(
  \head(\langle x \update t , v \rangle) \step t
  \)}
\hfill
\taut
\name{\(\Sigma\text{S}_2\)}
\UnaryInfC{\(
  \tail( \langle x \update t , v \rangle) \step [x \update t] v
  \)}
}
\end{flushleft}

\subsubsection*{Predicates}

\begin{flushleft}

\AxiomC{\( \Gamma \vdash p \colon \Sigma (x\colon \prop). t_1  \)}
\AxiomC{\( \Delta \vdash t_0 \colon \prop \)}
\name{\(\Sigma\)E}
\BinaryInfC{\(
  \Gamma, \, \Delta \vdash p_0 \, t_0 \colon [x \update t_0] t_1 \)}
\DisplayProof

\AxiomC{\( \Gamma , \, x \colon \prop \vdash p \colon t  \)}
\name{\(\Sigma\)I}
\UnaryInfC{\(
  \Gamma \vdash \Forall (x \colon \prop). p \colon \Sigma (x \colon \prop). t \)}
\DisplayProof

\taut
\name{\(\Sigma\)R}
\UnaryInfC{\(
  ( \Forall (x \colon \prop). p) \, t \step [x \update t] p
  \)}
\DisplayProof

\end{flushleft}

\subsubsection*{Satisfaction}
I can't figure out satisfaction at all.

\begin{flushleft}
\AxiomC{\(  v \models p \with [ \sigma , \, t \models x]\)}
\name{\(\Sigma\)S}
\UnaryInfC{\(
  \langle x \update t , v \rangle \models \Forall (x \colon \prop). p \with [\sigma]
  \)}
\DisplayProof
\end{flushleft}

\section*{Categorical Semantics}
%% Useful as hell, cite somewhere ?
%% https://tikzcd.yichuanshen.de/

The intent is to create calculi encoding the core features of the
double category \Rel.

If this is successful then terms and types ought to map to \Rel as
follows.

\begin{center}
  \begin{tikzcd}
    \unit \arrow{dd}[']{\sigma_p} \arrow{rr}{\sigma_v} & {} \arrow[Rightarrow]{dd}{v \models p \, [\sigma_v , \sigma_p]} & \times_{x\colon t \in \Gamma_v} t \arrow{dd}{v} \\
    &                               &                      \\
    \times_{x\colon t \in \Gamma_p} t \arrow{rr}[']{p}                           & {}                            & t                   
  \end{tikzcd}
\end{center}

\section*{The Future?}

Satisifies judgments correspond to thin squares. Moving to more
generally categories such as \textbf{Span} or \textbf{Prof} or
\textbf{Vect} for matrix math requires an interpretation of squares
carrying constructive content.

\end{document}
