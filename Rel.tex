% Formatting
\documentclass{scrartcl}

%% Fixers
\usepackage{fontspec}
\usepackage{realscripts}
\usepackage{xunicode}
\usepackage{polyglossia}

\usepackage[]{microtype}
%% \usepackage[top=0.7in, bottom=0.7in, left=0.6in, right=0.6in]{geometry}
\usepackage[english]{isodate}

% Packages
\usepackage{lastpage}
\usepackage{scrlayer-scrpage}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bussproofs}
\usepackage{stmaryrd}
\usepackage{supertabular}

\usepackage{tikz}
\usepackage{tikz-cd}

%Load Last Fixers

% Settings

\setdefaultlanguage{english}
\setotherlanguage{latin}

\setmainfont{Latin Modern Roman}[Ligatures=TeX,Fractions=On]
\setsansfont{Latin Modern Sans}[Ligatures=TeX,Fractions=On]
\setmonofont{Latin Modern Mono}[Ligatures=TeX,Fractions=On]

%% \hypersetup{bookmarksopen=true,colorlinks=true,allcolors=blue}

%% \setlength{\mathindent}{0pt}

\input{tex/test.tex}

\newcommand{\Rel}{\textbf{Rel}}
\newcommand{\Set}{\textbf{Set}}
\newcommand{\Span}{\textbf{Span}}
\newcommand{\Vect}{\textbf{Vect}}
\newcommand{\Prof}{\textbf{Prof}}
\newcommand{\lk}{\(\bar{\lambda}\mu\tilde{\mu}\,\)}

\newcommand{\name}[1]{\LeftLabel{\fbox{#1}}}
\newcommand{\apply}[1]{\RightLabel{\scriptsize{(#1)}}}

\newcommand{\side}[1]{\RightLabel{\scriptsize{\(\left\{#1\right\}\)}}}

\newcommand{\taut}{\AxiomC{\(\top\)}}
\newcommand{\bnfdef}{\mathrel{::=}}

\newcommand{\step}{\mathrel{\rightsquigarrow}}
\newcommand{\with}{\;}
\newcommand{\sat}{\mathbin{\otimes}}

\def\fCenter{\mathrel{\vdash}}

\newcommand{\axiom}[2]{\fbox{#1}~#2}

%% \newcommand{\axiom}[2]{\begin{prooftree}\name{#1}\AxiomC{\(\top\)}\UnaryInfC{#2}\end{prooftree}}

\DeclareMathOperator{\val}{\textbf{v}}
\DeclareMathOperator{\prd}{\textbf{p}}

\DeclareMathOperator{\unit}{\top}
\DeclareMathOperator{\mt}{\emptyset}
\DeclareMathOperator{\coin}{\textbf{!}}
\DeclareMathOperator{\fst}{\pi_1}
\DeclareMathOperator{\snd}{\pi_2}

\DeclareMathOperator{\success}{\textbf{true}}
\newcommand{\pass}{\mathbin{\gg}}

\DeclareMathOperator{\absurd}{\textbf{abort}}
\DeclareMathOperator{\inl}{\textbf{i}_1}
\DeclareMathOperator{\inr}{\textbf{i}_2}

\DeclareMathOperator{\false}{\textbf{false}}
\DeclareMathOperator{\lft}{\textbf{l}}
\DeclareMathOperator{\rgt}{\textbf{r}}

\DeclareMathOperator{\type}{\Box}
\DeclareMathOperator{\prop}{*}
\newcommand{\Type}{\textbf{Type}}

\DeclareMathOperator{\head}{\textbf{h}}
\DeclareMathOperator{\tail}{\textbf{t}}

\newcommand{\Forall}{\Lambda}

\newcommand{\update}{\mathbin{:=}}

\DeclareMathOperator{\case}{\textbf{m}}

\begin{document}

\title{Internal Language of Rel}
\author{Molly Stewart-Gallus}

\maketitle

I wanted an internal language corresponding to the double category
\Rel{} the double category with sets as objects, relations as
horizontal arrows and functions as vertical arrows.

I present three different calculi: a substructural ``context
calculus'' corresponding to the horizontal edge of \Rel{}; a ``term
calculus'' corresponding to \Set{}, the vertical edge category of
\Rel{}; and a simple ``command calculus'' corresponding to commuting
squares of \Rel{}.

First, I give the basic framework of the calculi. Then I discuss
semantics and applications. And finally I list a few possible
extensions such as coproduct and dependent sum types.

\section*{Core Calculi}

The core context calculus is the linear lambda calculus with a few
symbol changes and corresponds to the closed monoidal structure of the
horizontal edge of \Rel{}.  The core term calculus is a little
language with only product types and corresponds to the Cartesian
structure of \Set{}.  I am still figuring out the core command
calculus which ought to correspond to commuting squares in \Rel{}.

The context calculus has a linear variable rule.  To make
mechanization easier and ensure the typing environment can always be
directly inferred from context expressions linear variables are
explicitly indexed by their types and variable binding is more
imperative.

\subsection*{Grammar, Syntax and Reductions}

\begin{flushleft}
\ottgrammartabular{
\otttype\ottinterrule
\ottterm\ottinterrule
\ottnormal\ottinterrule
\ottcontext\ottinterrule
\ottenvironment\ottinterrule
\ottseq
%% \otttermXXctx\ottinterrule
%% \ottcontextXXctx\ottinterrule
%% \ottcontextXXwhnf\ottinterrule
%% \ottterminals\ottinterrule
%% \ottformula\ottinterrule
%% \ottjudge\ottinterrule
%% \otteval\ottinterrule
%% \ottjudgement\ottinterrule
%% \ottuserXXsyntax
\ottafterlastrule
}

\ottdefnss
\end{flushleft}

\begin{center}

\[\begin{aligned}
&\textbf{Types} &  t & \bnfdef \prop \mid t \times t  \\
&\textbf{Contexts}  & E & \bnfdef x_t \mid E \, E \mid \lambda (x \colon t) . E  \\
&\textbf{Terms} &  v & \bnfdef x \mid \fst(v) \mid \snd(v) \mid v , v  \\
&\textbf{Environment}  &  \Gamma & \bnfdef \cdot \mid \Gamma , \, x \colon t   \\
&\textbf{Command Env}  &  \Delta & \bnfdef \cdot \mid \Delta , \, x \sat v  
\end{aligned}\]


\subsubsection*{Context Calculus}
 
\axiom{V}
      {\(\cdot , \, x \colon t \vdash x_t \colon t\)}

      
\begin{prooftree}
\name{\(\times\)I}
\Axiom$\Gamma \fCenter E \colon t_1$
\side{ x \colon t_0 \in \Gamma }
\UnaryInf$\Gamma \setminus x \fCenter \lambda (x \colon t_0). E \colon t_0 \times t_1$
\end{prooftree}

\begin{prooftree}
\name{\(\times\)E}
\Axiom$\Gamma_0 \fCenter E_0 \colon t_0 \times t_1$
\Axiom$\Gamma_1 \fCenter E_1 \colon t_0$
\BinaryInf$\Gamma_0, \, \Gamma_1 \fCenter E_0 \, E_1 \colon t_1$
\end{prooftree}

\axiom{\(\times\beta\)}
      {\( ( \lambda (x \colon t ). E_0) \, E_1 \step [x_t \update E_1] E_0 \)}

\subsubsection*{Term Calculus}

\begin{prooftree}
\name{V}
\AxiomC{\(x \colon t \in \Gamma\)}
\UnaryInf$\Gamma \fCenter x \colon t$
\end{prooftree}

\begin{prooftree}
\name{\(\times\)I}
\Axiom$\Gamma \fCenter v_0 \colon t_0$
\Axiom$\Gamma \fCenter v_1 \colon t_1$
\BinaryInf$\Gamma \fCenter v_0, v_1 \colon t_0 \times t_1$
\end{prooftree}

{\name{\(\times\text{E}_1\)}
\Axiom$\Gamma \fCenter v \colon t_0 \times t_1$
\UnaryInf$\Gamma \fCenter \fst(v) \colon t_0$
\DisplayProof
\hfill
\name{\(\times\text{E}_2\)}
\Axiom$\Gamma \fCenter v \colon t_0 \times t_1$
\UnaryInf$\Gamma \fCenter \snd(v) \colon t_1$
\DisplayProof}

{\axiom{\(\times\beta_1\)}
       {\(\fst (v_0 , v_1 ) \step v_0 \)}
\hfill
\axiom{\(\times\beta_2\)}
      {\(\snd (v_0 , v_1 ) \step v_1 \)}
}

\subsubsection*{Command Calculus}

\axiom{V}
      {\(\cdot , \, x_t \sat v  \fCenter  x_t \sat v \)}

{\name{v}
\Axiom$\Delta \fCenter E \sat v_0$
\AxiomC{\(v_0 \step v_1\)}
\BinaryInf$\Delta \fCenter E \sat v_1$
\DisplayProof
\hfill
\name{E}
\Axiom$\Delta \fCenter E_0 \sat v$
\AxiomC{\(E_0 \step E_1\)}
\BinaryInf$\Delta \fCenter E_1 \sat v$
\DisplayProof}

\begin{prooftree}
\name{\(\times\)I}
\Axiom$ \Delta , \,  x_t \sat v_0  \fCenter E \sat v_1 $
\UnaryInf$ \Delta \fCenter \lambda (x \colon t ). E \sat  v_0 , v_1 $
\end{prooftree}


\begin{prooftree}
\name{\(\times\)E}
\Axiom$ \Delta_0 \fCenter E_0 \sat v $
\Axiom$ \Delta_1 \fCenter E_1 \sat \fst(v) $
\BinaryInf$ \Delta_0 , \, \Delta_1 \fCenter E_0 \, E_1 \sat \snd(v) $
\end{prooftree}


\end{center}

\section*{Examples}

%% Technical choices

%% I decided against rules for mapping from \Set{} to \Rel{} because I wanted
%% to see how far \Rel{} could go on its own and also wanted to see if
%% these could be defined later.

\subsection*{Identity}

\( \textbf{id}_t = \lambda (x \colon t). \, x_t \)
{\taut
  \apply{V}
  \UnaryInf$ \cdot , \, x \colon t \fCenter x_t \colon t $
  \apply{\(\times\)I}
  \UnaryInf$ \cdot \fCenter  \lambda (x \colon t). \, x_t \colon t \times t $
  \DisplayProof}
\hfill
{\taut
  \apply{V}
  \UnaryInf$ \Delta , \,  x_t \sat v  \fCenter  x_t \sat v $
  \apply{\(\times\)I}
  \UnaryInf$ \Delta \fCenter  \lambda (x \colon t). \, x_t  \sat v , v $
  \DisplayProof}

\subsection*{Composition}

\begin{center}

  \[ f \circ_t g = \lambda (x \colon t). \, f \, (g \, x_t) \]

\begin{prooftree}

  \Axiom$ \cdot \fCenter f \colon t_1 \times t_2 $

  \Axiom$ \cdot \fCenter g \colon t_0 \times t_1 $
  \taut
  \apply{\(\times\)V}
  \UnaryInf$ \cdot , \, x \colon t_0 \fCenter x_{t_0} \colon t_0 $

  \apply{\(\times\)E}
  \BinaryInf$ \cdot , \, x \colon t_0 \fCenter g \, x_{t_0} \colon t_1 $

  \apply{\(\times\)E}
  \BinaryInf$ \cdot , \, x \colon t_0 \fCenter f \, (g \, x_{t_0}) \colon t_2 $
  \apply{\(\times\)I}
  \UnaryInf$ \cdot \fCenter \lambda (x \colon t_0). \, f \, (g \, x_{t_0}) \colon t_0 \times t_2 $

\end{prooftree}

\begin{prooftree}

  \Axiom$ \cdot \fCenter f \sat v_1 , \, v_2 $

  \Axiom$ \cdot \fCenter g \sat v_0 , \, v_1 $

  \taut
  \apply{V}
  \UnaryInf$ \cdot , \, x_{t_0} \sat v_0 \fCenter x_{t_0} \sat v_0  $

  \apply{\(\times\)E}
  \BinaryInf$ \cdot , \,  x_{t_0} \sat v_0 \fCenter g \, x_{t_0} \sat v_1 $

  \apply{\(\times\)E}
  \BinaryInf$ \cdot , \,  x_{t_0} \sat v_0  \fCenter  f \, (g \, x_{t_0})  \sat v_2 $
  \apply{\(\times\)I}
  \UnaryInf$ \cdot \fCenter \lambda (x \colon t_0). \, f \, (g \, x_{t_0})  \sat v_0 , v_2 $
\end{prooftree}

\end{center}

\section*{Categorical Semantics}
%% Useful as hell, cite somewhere ?
%% https://tikzcd.yichuanshen.de/

The intent is to create calculi encoding the core features of the
double category \Rel{}.  If this is successful then terms and types
ought to map to \Rel{} as follows.

I think you want pullbacks for the environment arrows?

\begin{center}
  \begin{tikzcd}
   ? \arrow{dd}[']{?} \arrow{rr}{?} & {} \arrow[Rightarrow]{dd}{\Delta \fCenter E \sat v} & \times_{x\colon t \in \Gamma_v} t \arrow{dd}{v} \\
    &                               &                      \\
    \times_{x\colon t \in \Gamma_E} t \arrow{rr}[']{E}                           & {}                            & t                   
  \end{tikzcd}
\end{center}

I have no idea about universe issues and such. Dependent sum is probably wrong.

Really need to think about denotation again.

\[
\begin{aligned}
  \llbracket t_0 \times t_1 \rrbracket & =\llbracket t_0 \rrbracket \times \llbracket t_1 \rrbracket \\
  \\
  \llbracket x \rrbracket(\sigma) & = \sigma(x) \\
  \llbracket v_0 , v_1 \rrbracket(\sigma) & =( \llbracket v_0 \rrbracket(\sigma) , \llbracket v_1 \rrbracket(\sigma) ) \\
  \\
  \llbracket x_t \rrbracket(\sigma, s) & = \sigma(x, s) \\
  \llbracket E_0 \, E_1 \rrbracket(\sigma, s_0) & = \exists s_1,  \llbracket E_1 \rrbracket (\sigma, s_1) \wedge \llbracket E_0 \rrbracket (\sigma, (s_1, s_0))\\
  \llbracket \lambda (x \colon t). E_0 \rrbracket(\sigma, (s_0, s_1)) & = \lambda E_1, \llbracket E_1 \rrbracket (\sigma, s_0) \rightarrow \llbracket E_0 \rrbracket ([x \update  s \mapsto \llbracket E_1 \rrbracket(\sigma, s)] \sigma, s_1) 
\end{aligned}
\]

\section*{Applications to Synthetic Category Theory}

A category is a monad in \Span{}.  Once this system has been generalized
to \Span{} we can define monads internal to \Span{}.

This is not fully internal but a simple approach to defining an
equivalence relation might be something like:

\begin{center}

{\axiom{object}{\( \cdot \fCenter O \colon \prop \)}\hfill
\axiom{arrow}{\( \cdot \fCenter R \colon O \times O \)}}

\name{refl}
\Axiom$\cdot \fCenter o \colon O$
\UnaryInf$\cdot \fCenter R \sat o, o $
\DisplayProof

\name{trans}
\Axiom$ \cdot \fCenter  \lambda (x\colon O). R \, (R \, x)  \sat o_0, o_1 $
\side{\cdot \fCenter o_1, o_0 \colon O \times O}
\UnaryInf$ \cdot \fCenter  R \sat o_0, o_1 $
\DisplayProof

\name{sym}
\Axiom$ \cdot \fCenter  R \sat o_0, o_1  $
\side{\cdot \fCenter o_1, o_0 \colon O \times O}
\UnaryInf$ \cdot \fCenter  R \sat o_1, o_0 $
\DisplayProof
      
\end{center}

Generalizing to a constructive interpretation in terms of spans and
groupoids is future work.

\section*{Extensions}

Singleton set, disjoint union and dependent sum types.

\subsection*{Unit Type}

\begin{center}

\[\begin{aligned}
&\textbf{Types} &  t & \bnfdef \ldots \mid 1  \\
&\textbf{Contexts}  & E & \bnfdef \ldots \mid \success \mid E \pass E  \\
&\textbf{Terms} &  v & \bnfdef \ldots \mid \coin 
\end{aligned}\]

\subsubsection*{Context Calculus}

{\axiom{\(\unit\)I}
      {\(\cdot \vdash \success \colon \unit\)}
\hfill
\begin{prooftree}
\name{\(\unit\)E}
\Axiom$\Gamma_0 \fCenter p_0 \colon \unit$
\Axiom$\Gamma_1 \fCenter p_1 \colon t$
\BinaryInf$\Gamma_0, \, \Gamma_1 \fCenter E_0 \pass E_1 \colon t$
\end{prooftree}}

\axiom{\(\unit\beta\)}
      {\(\success \pass E \step E \)}

\subsubsection*{Term Calculus}

\axiom{\(\unit\)I}
      {\(\Gamma \fCenter \coin \colon \unit \)}

\subsubsection*{Command Calculus}

\axiom{\(\unit\)I}
      {\(\cdot \fCenter \success \sat \coin \)}

\begin{prooftree}
\name{\(\unit\)E}
\Axiom$ \Delta_0 \fCenter \success \sat \coin $
\Axiom$ \Delta_1 \fCenter E \sat v $
\BinaryInf$ \Delta_0 , \, \Delta_1 \fCenter E \sat v $
\end{prooftree}

\end{center}

\section*{Disjoint Unions}

Disjoint unions in \Set{} become Cartesian products/coproducts in
\Rel{}.

%% I have a hunch it is proper for the combination of product/coproduct
%% to introduce nondeterminism in the operational semantics but I need to
%% think more about the issue.

As a technical hack \(\false\) is explicitly indexed by the environment it ignores.
This hack also requires inferring the environment in certain reduction rules.

\begin{center}

\[\begin{aligned}
& \textbf{Types} & t & \bnfdef \ldots \mid \mt \mid t + t \\
& \textbf{Contexts} & E & \bnfdef \ldots \mid
  \absurd_t(E) \mid \inl_t(E) \mid \inr_t(E) \mid \\
&                     & & \case(v, E. v, x. E) \mid \false_\Gamma \mid \lft(E) \mid \rgt(E) \mid E ; E  \\
& \textbf{Terms} & v & \bnfdef \ldots \mid \absurd_t(v) \mid \inl_t(v) \mid \inr_t(v) \mid
  \case(v, x. v, x. v)
\end{aligned}\]

\subsubsection*{Context Calculus}

\name{\(\mt\text{E}^\text{T}\)}
\Axiom$\Gamma \fCenter E \colon \mt$
\UnaryInf$\Gamma \fCenter \absurd_t(E) \colon t$
\DisplayProof

{\name{\(+\text{I}^\text{T}_1\)}
\Axiom$\Gamma \fCenter E \colon t_0$
\UnaryInf$\Gamma \fCenter \inl_{t_1}(E) \colon t_0 + t_1$
\DisplayProof
\hfill
\name{\(+\text{I}^\text{T}_2\)}
\Axiom$\Gamma \fCenter E \colon t_1$
\UnaryInf$\Gamma \fCenter \inr_{t_0}(E) \colon t_0 + t_1$
\DisplayProof}

\name{\(+\text{E}^\text{T}\)}
\Axiom$ \Gamma \fCenter E_0 \colon t_0 + t_1 $
\Axiom$ \Gamma , \, x_0 \colon t_0 \fCenter E_1 \colon t_2 $
\Axiom$ \Gamma , \, x_1 \colon t_1 \fCenter E_1 \colon t_2 $
\TrinaryInf$ \Gamma \fCenter \case(E_0, x_0. E_1, x_1. E_2) \colon t_2 $
\DisplayProof

\axiom{\(\mt\)I}
      {\( \Gamma \fCenter \false_\Gamma \colon \mt \)}

{\name{\(+\text{E}_1\)}
\Axiom$\Gamma \fCenter E \colon t_0 + t_1$
\UnaryInf$\Gamma \fCenter \lft(E) \colon t_0$
\DisplayProof
\hfill
\name{\(+\text{E}_2\)}
\Axiom$\Gamma \fCenter E \colon t_0 + t_1$
\UnaryInf$\Gamma \fCenter \rgt(E) \colon t_1)$
\DisplayProof
}

\name{\(+\)I}
\Axiom$ \Gamma \fCenter E_0 \colon t_0 $
\Axiom$ \Gamma \fCenter E_1 \colon t_1 $
\BinaryInf$ \Gamma \fCenter E_0 ; E_1 \colon t_0 + t_1 $
\DisplayProof

\axiom{\(+\beta^\text{T}_1\)}
      {\(
  \case(\inl_t(E_0), x_0. E_1, x_1. E_2) \step [x_0 \update E_0] E_1
  \)}

\axiom{\(+\beta^\text{T}_2\)}
      {\(
  \case(\inr_t(E_0), x_0. E_1, x_1. E_2) \step [x_1 \update E_0] E_2
  \)}

{\axiom{\(+\beta_1\)}{\( \lft(E_0 ; E_1) \step E_0 \)}
\hfill
\axiom{\(+\beta_2\)}{\( \rgt(E_0 ; E_1) \step E_1 \)}}

{
\axiom{\(+\beta\beta^\text{T}_1\)}
      {\( \lft(\inl_t(E)) \step E \)}
\hfill
\axiom{\(+\beta\beta^\text{T}_2\)}
      {\( \rgt(\inr_t(E)) \step E \)}
}

{\name{\(+\text{R}\text{R}^\text{T}_3\)}
\Axiom$\Gamma \fCenter E \colon t$
\UnaryInfC{\(\lft(\inr_t(E)) \step \absurd_t(\false_\Gamma)\)}
\DisplayProof
\hfill
\name{\(+\text{R}\text{R}^\text{T}_4\)}
\Axiom$\Gamma \fCenter E \colon t$
\UnaryInfC{\(\rgt(\inl_t(E)) \step \absurd_t(\false_\Gamma)\)}
\DisplayProof
}

\axiom{\(+\text{R}^\text{T}\text{R}_1\)}
      {\(\case(E_0 ; E_1, x_0. E_2, x_1. E_3) \step [x_0 := E_0] E_2\)}

\axiom{\(+\text{R}^\text{T}\text{R}_2\)}
      {\( \case(E_0 ; E_1, x_0. E_2, x_1. E_3) \step [x_1 := E_1] E_3 \)}

\subsubsection*{Term Calculus}

\name{\(\mt\)E}
\Axiom$\Gamma \fCenter v \colon \mt$
\UnaryInf$\Gamma \fCenter \absurd_t(v) \colon t$
\DisplayProof

{\name{\(+\text{I}_1\)}
\Axiom$\Gamma \fCenter v \colon t_0$
\UnaryInf$\Gamma \fCenter \inl_{t_1}(v) \colon t_0 + t_1$
\DisplayProof
\hfill
\name{\(+\text{I}_2\)}
\Axiom$\Gamma \fCenter v \colon t_1$
\UnaryInf$\Gamma \fCenter \inr_{t_0}(v) \colon t_0 + t_1$
\DisplayProof
}

\name{\(+\)E}
\Axiom$ \Gamma \fCenter v_0 \colon t_0 + t_1 $
\Axiom$ \Gamma , \, x_0 \colon t_0 \fCenter v_1 \colon t_2 $
\Axiom$ \Gamma , \, x_1 \colon t_1 \fCenter v_1 \colon t_2 $
\TrinaryInf$ \Gamma \fCenter \case(v_0, x_0. v_1, x_1. v_2) \colon t_2 $
\DisplayProof

\axiom{\(+\beta_1\)}
      {\( \case(\inl_t(v_0), x_0. v_1, x_1. v_2) \step [x_0 \update v_0] v_1 \)}

\axiom{\(+\beta_2\)}
      {\( \case(\inr_t(v_0), x_0. v_1, x_1. v_2) \step [x_1 \update v_0] v_2 \)}

\subsubsection*{Command Calculus}

{\name{\(+\text{I}_1\)}
\Axiom$\Delta \fCenter E_0 \sat v $
\UnaryInf$\Delta \fCenter E_0 ; E_1 \sat \inl_t(v) $
\DisplayProof
\hfill
\name{\(+\text{I}_2\)}
\Axiom$\Delta \fCenter  E_1 \sat v$
\UnaryInf$\Delta \fCenter  E_0 ; E_1 \sat \inr_t(v) $
\DisplayProof
}

\name{\(\mt\)I}
\Axiom$\Delta \fCenter E \sat \absurd_t(v) $
\UnaryInf$\Delta \fCenter \false_\Gamma \sat v $
\DisplayProof

\end{center}

\section*{Dependent Sums}

If product of sets becomes an internal hom in the predicate calculus
then dependent sums ought to become a little like \(\Pi\) types.  So
the predicate calculus effectively becomes like a linear System-F.

Some things become awkward to interpret here though.

I also really can't figure out unpacking. It's messy if you don't want
full dependent types.

Not really good at the typing judgements for dependent sum types.

\begin{center}

\[\begin{aligned}
& \textbf{Types} & t & \bnfdef \ldots \mid x \mid \prop \mid \head(v) \mid \Sigma (x \colon \prop). t  \\
& \textbf{Contexts} &  E & \bnfdef \ldots \mid E \, t \mid \lambda (x \colon \prop). E  \\
& \textbf{Terms} &  v & \bnfdef \ldots \mid \tail(v) \mid \langle x \update t , v \rangle  \\
& \textbf{Command Env} & \Delta & \bnfdef \ldots \mid \Delta , \, x \sat t 
\end{aligned}\]

\subsubsection*{Context Calculus}

\name{\(\Sigma\)E}
\Axiom$ \Gamma_0 \fCenter E \colon \Sigma (x\colon \prop). t_1 $
\Axiom$ \Gamma_1 \fCenter t_0 \colon \prop $
\BinaryInf$ \Gamma_0, \, \Gamma_1 \fCenter E_0 \, t_0 \colon [x \update t_0] t_1 $
\DisplayProof

\name{\(\Sigma\)I}
\Axiom$ \Gamma , \, x \colon \prop \fCenter E \colon t $
\UnaryInf$ \Gamma \fCenter \lambda (x \colon \prop). E \colon \Sigma (x \colon \prop). t $
\DisplayProof

\axiom{\(\Sigma\beta\)}{\( ( \lambda (x \colon \prop). E) \, t \step [x \update t] E \)}

\subsubsection*{Term Calculus}

%% \axiom{U}
%%       {\(\Gamma \fCenter U_i \, \Type\)}

%% \name{U}
%% \Axiom$\Gamma \fCenter v \colon U_i$
%% \UnaryInf$\Gamma \fCenter \llbracket v \rrbracket \, \Type$
%% \DisplayProof

%% \axiom{U}
%%       {\(\Gamma \fCenter u_i : U_{i+1} \)}

%% \name{U}
%% \Axiom$\Gamma \fCenter v \colon U_i$
%% \UnaryInf$\Gamma \fCenter \llbracket v \rrbracket \, \Type$
%% \DisplayProof

\name{\(\Sigma\text{E}_1\)}
\Axiom$\Gamma \fCenter E \colon \Sigma (x \colon \prop). t$
\UnaryInf$\Gamma \fCenter \head(v) \colon \prop$
\DisplayProof

\name{\(\Sigma\text{E}_2\)}
\Axiom$\Gamma \fCenter v \colon \Sigma (x \colon \prop). t$
\UnaryInf$\Gamma \fCenter \tail(v) \colon [x \update \head(v)] t$
\DisplayProof

\name{\(\Sigma\)I}
\Axiom$ \Gamma \fCenter t_0 \colon \prop $
\Axiom$ \Gamma , \, x \colon \prop \fCenter v \colon t_1 $
\BinaryInf$\Gamma \fCenter \langle x \update t_0 , v \rangle \colon \Sigma (x \colon \prop). t_0 $
\DisplayProof

{\axiom{\(\Sigma\beta_1\)}{\( \head(\langle x \update t , v \rangle) \step t \)}
\hfill
\axiom{\(\Sigma\beta_2\)}{\( \tail( \langle x \update t , v \rangle) \step [x \update t] v \)}
}

\subsubsection*{Command Calculus}

\name{\(\Sigma\)I}
\Axiom$ \Delta , \,  x \sat t  \fCenter E \sat v $
\UnaryInf$ \Delta \fCenter  \lambda (x \colon \prop). E \sat \langle x \update t , v \rangle $
\DisplayProof

\end{center}

I can't figure out commands here at all.

\section*{The Future?}

Satisifies judgments correspond to thin squares. Moving to more
general categories such as \Span{} or \Prof{} or
\Vect{} for matrix math requires an interpretation of squares
carrying constructive content.

\end{document}
