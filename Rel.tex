% Formatting
\documentclass[twocolumn, fleqn]{scrartcl}

%% Fixers
\usepackage{fontspec}
\usepackage{realscripts}
\usepackage{xunicode}
\usepackage{polyglossia}

\usepackage[]{microtype}
\usepackage[top=0.7in, bottom=0.75in, left=0.75in, right=0.7in]{geometry}
\usepackage[english]{isodate}

% Packages
\usepackage{lastpage}
\usepackage{scrlayer-scrpage}
\usepackage{enumitem}
\usepackage{amsmath}

\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{multicol}

%Load Last Fixers
\usepackage{hyperref}

% Settings

\setdefaultlanguage{english}
\setotherlanguage{latin}

\setmainfont{Latin Modern Roman}[Ligatures=TeX,Fractions=On]
\setsansfont{Latin Modern Sans}[Ligatures=TeX,Fractions=On]
\setmonofont{Latin Modern Mono}[Ligatures=TeX,Fractions=On]

\hypersetup{bookmarksopen=true,colorlinks=true,allcolors=blue}

\setlength{\mathindent}{0pt}

\newcommand{\Rel}{\textbf{Rel}}

\newcommand{\bnfdef}{\mathbin{::=}}

\DeclareMathOperator{\coin}{\textbf{tt}}
\DeclareMathOperator{\fst}{\textbf{fst}}
\DeclareMathOperator{\snd}{\textbf{snd}}

\DeclareMathOperator{\inl}{\textbf{inl}}
\DeclareMathOperator{\inr}{\textbf{inr}}

\DeclareMathOperator{\false}{\textbf{false}}
\DeclareMathOperator{\lft}{\textbf{left}}
\DeclareMathOperator{\rgt}{\textbf{right}}

\DeclareMathOperator{\type}{\textbf{type}}

\DeclareMathOperator{\update}{:=}

\DeclareMathOperator{\case}{\textbf{match}}
\DeclareMathOperator{\with}{\textbf{with}}
\DeclareMathOperator{\esac}{\textbf{end}}

\begin{document}

I wanted to try out making a programming language vaguely
corresponding to the double category \(\Rel\).

You have a calculus of ``values'' corresponding to one edge of
\(\Rel\) and a sort of relational calculus of ``predicates''
corresponding to the other edge. Satisfies judgements stating a value
satisfies a predicate ought to correspond to squares.

The language of ``predicates'' is based off the Simply Typed Lambda
Calculus (in category theory terms is closed/has exponential objects)
and the language of ``values'' has product types (in category theory
terms is Cartesian.)

This is the core framework.  I've been thinking about further
extensions but I want to see how far I can get characterizing
\(\Rel\) with as few language features as possible.  Later on I
give a few possible extensions.

\section*{Core Calculus}

\begin{description}
\item[Types] \( t \bnfdef \top \mid t \times t \)
\item[Sorts] \( s \bnfdef t ? \mid t ! \)
\item[Values] \( v \bnfdef x \mid \fst(v) \mid \snd(v) \mid ( v , v )  \)
\item[Predicates] \( p \bnfdef x \mid p \, p \mid \mu (x \colon t ?) . p \)
\item[Environment] \( \Gamma \bnfdef \cdot \Gamma , \, \mid x \colon s  \)
\item[Substitutions] \( \sigma \bnfdef \cdot \sigma , \, \mid v \models x  \)
\end{description}

I need a better name for the abstraction for predicates. It's a little
like the \(\mu\) abstraction \(\bar{\lambda} \mu \tilde{\mu}\) but
different.

Typing judgments.

\begin{multline*}
  \frac{
  }{
    \Gamma \vdash \coin \colon \top !
  }\\
  \frac{
    \Gamma \vdash v \colon t_0 \times t_1 !
  }{
    \Gamma \vdash \fst(v) \colon t_0 !
  }\\
  \frac{
    \Gamma \vdash v \colon t_0 \times t_1 !
  }{
    \Gamma \vdash \snd(v) \colon t_1 !
  }\\
  \frac{
    \Gamma \vdash v_0 \colon t_0 ! \quad
    \Gamma \vdash v_1 \colon t_1 !
  }{
    \Gamma \vdash ( v_0 , v_1 ) \colon t_0 \times t_1 !
  }\\
  \frac{
    \Gamma \vdash p_0 \colon t_0 \times t_1 ? \quad
    \Gamma \vdash p_1 \colon t_0 ?
  }{
    \Gamma \vdash p_0 \, p_1 \colon t_1 ?
  }\\
  \frac{
    \Gamma , \, x \colon t_0 ? \vdash p \colon t_1 ?
  }{
    \Gamma \vdash \mu x \colon t_0 ? . p \colon t_0 \times t_1 ?
  }\\
\end{multline*}

When a value satisfies a predicate (I need a better symbol here.)

\begin{multline*}
\frac{
  v_0 \models p \; [\sigma]
}{
  \fst ( v_0 , v_1 ) \models p \; [\sigma]
}\\
\frac{
  v_1 \models p \; [\sigma]
}{
  \snd ( v_0 , v_1 ) \models p \; [\sigma]
}\\
\frac{
  v \models [x \colon= p_1] p_0 \; [\sigma]
}{
  v \models ( \mu (x \colon t ?). p_0) \, p_1 \; [\sigma]
}\\
\frac{
  v_1 \models p \; [ \sigma , \, v_0 \models x]
}{
  ( v_0 , v_1 ) \models \mu (x \colon t ?). p \; [\sigma]
}\\
\end{multline*}

Example

\begin{multline*}
   ( v , v ) \models \mu (x \colon t ?). x \; [\sigma]\\
\end{multline*}

Transposition

\begin{multline*}
   \textbf{M} (A \colon \type). \mu (p \colon A \times A \times \top) (x \colon A) (y \colon A). p \, y \, x\\
\end{multline*}

\section*{Disjoint Unions}

I am fairly confident in a simple extension to disjoint unions
of sets which are sum types in the value calculus and product types in
the predicate calculus.

\begin{description}
\item[Types] \( t \bnfdef \ldots \mid \bot \mid t + t \)
\item[Values] \( v \bnfdef \ldots \mid \inl(t, v) \mid \inr(t, v) \mid
  \case \, v \,
  \begin{cases}
    v & \leftarrow \inl(x) \\
    v & \leftarrow \inr(x)
  \end{cases}
  \)
\item[Predicates] \( p \bnfdef \ldots \mid \false \mid \lft(p) \mid \rgt(p) \mid [ p ; p ] \)
\end{description}

Typing judgments.

\begin{multline*}
\frac{
  \Gamma \vdash v \colon t_0 !
}{
  \Gamma \vdash \inl(t_1, v) \colon t_0 + t_1 !
}\\
\frac{
  \Gamma \vdash v \colon t_1 !
}{
  \Gamma \vdash \inr(t_0, v) \colon t_0 + t_1 !
}\\
\frac{
  \Gamma \vdash v_0 \colon t_0 + t_1 ! \;
  \Gamma , \, x_0 \colon t_0 ! \vdash v_1 \colon t_2 ! \;
  \Gamma , \, x_1 \colon t_1 ! \vdash v_2 \colon t_2 !
}{
  \Gamma \vdash
  \case \, v_0 \,
  \begin{cases}
   v_1 & \leftarrow \inl(x_0) \\
   v_2 & \leftarrow \inr(x_1)
  \end{cases}
  \colon t_2 !
}\\
\frac{
}{
  \Gamma \vdash \false \colon \bot ?
}\\
\frac{
  \Gamma \vdash p \colon t_0 + t_1 ?
}{
  \Gamma \vdash \lft(p) \colon t_0 ?
}\\
\frac{
  \Gamma \vdash p \colon t_0 + t_1 ?
}{
  \Gamma \vdash \rgt(p) \colon t_1 ?
}\\
\frac{
  \Gamma \vdash p_0 \colon t_0 ? \quad
  \Gamma \vdash p_1 \colon t_1 ?
}{
  \Gamma \vdash [ p_0 ; p_1 ] \colon t_0 + t_1 ?
}\\
\end{multline*}

Satisfies

\begin{multline*}
\frac{
  [x_0 \update v_0] v_1 \models p \; [\sigma]
}{
  \case \, \inl(t, v_0) \,
  \begin{cases}
    v_1 & \leftarrow \inl(x_0) \\
    v_2 & \leftarrow \inr(x_1)
  \end{cases}
 \models p \; [\sigma]
}\\
\frac{
  [x_1 \update v_0] v_2 \models p \; [\sigma]
}{
  \case \, \inr(t, v_0) \,
  \begin{cases}
    v_1 & \leftarrow \inl(x_0) \\
    v_2 & \leftarrow \inr(x_1)
  \end{cases}
  \models p \; [\sigma]
}\\
\frac{
  v \models p_0 \; [\sigma]
}{
  v \models \lft([ p_0 ; p_1 ]) \; [\sigma]
}\\
\frac{
  v \models p_1 \; [\sigma]
}{
  v \models \rgt([ p_0 ; p_1 ])  \; [\sigma]
}\\
\frac{
  v \models p_0 \; [\sigma]
}{
  \inl(t, v) \models [ p_0 ; p_1 ]  \; [\sigma]
}\\
\frac{
  v \models p_1 \; [\sigma]
}{
  \inr(t, v) \models [ p_0 ; p_1 ]  \; [\sigma]
}\\
\end{multline*}

\section*{Dependent Sums}

If product of sets becomes an exponential in the predicate calculus
then dependent sums ought to become like \(\Pi\) types.  So the
predicate calculus effectively becomes like System-F.

Some things become awkward to interpret here though.

I also really can't figure out unpacking. It's messy if you don't want
full dependent types.

\begin{description}
\item[Types] \( t \bnfdef \ldots \mid x \mid \Sigma (x \colon \type). t \)
\item[Sorts] \( s \bnfdef \ldots \mid \type \)
\item[Values] \( v \bnfdef \ldots \mid \langle x \colon= t , v \rangle \)
\item[Predicates] \( p \bnfdef \ldots \mid p \, t \mid \textbf{M} (x \colon \type). p \)
\item[Substitutions] \( \sigma \bnfdef \ldots \sigma , \, \mid t \models x \)
\end{description}

Not really good at the typing judgements for dependent sum types.

\begin{multline*}
\frac{
  \Gamma \vdash t_0 \colon \type \quad
  \Gamma , \, x \colon \type \vdash v \colon t_1 !
}{
  \Gamma \vdash \langle x \update t_0 , v \rangle \colon \Sigma (x \colon \type). t_0 !
}\\
\frac{
  \Gamma \vdash p \colon \Sigma (x\colon \type). t_1 ? \quad
  \Gamma \vdash t_0 \colon \type
}{
  \Gamma \vdash p_0 \, t_0 \colon [x \colon= t_0] t_1 ?
}\\
\frac{
  \Gamma , \, x \colon \type \vdash p \colon t ?
}{
  \Gamma \vdash \textbf{M} (x \colon \type). p \colon \Sigma (x\colon \type). t ?
}\\
\end{multline*}

I can't figure out satisfaction at all.

\begin{multline*}
\frac{
  v \models [x \update t] p \; [\sigma]
}{
  v \models ( \textbf{M} (x \colon \type). p) \, t \; [\sigma]
}\\
\frac{
  v \models p \; [ \sigma , \, t \models x]
}{
  \langle x \update t , v \rangle \models \textbf{M} (x \colon \type). p \; [\sigma]
}\\
\end{multline*}

\end{document}
