% Formatting
\documentclass[twocolumn]{scrartcl}

%% Fixers
\usepackage{fontspec}
\usepackage{realscripts}
\usepackage{xunicode}
\usepackage{polyglossia}

\usepackage[]{microtype}
\usepackage[top=0.7in, bottom=0.75in, left=0.75in, right=0.7in]{geometry}
\usepackage[english]{isodate}

% Packages
\usepackage{lastpage}
\usepackage{scrlayer-scrpage}
\usepackage{enumitem}
\usepackage{amsmath}

\usepackage{tikz}
\usepackage{tikz-cd}

%Load Last Fixers

% Settings

\setdefaultlanguage{english}
\setotherlanguage{latin}

\setmainfont{Latin Modern Roman}[Ligatures=TeX,Fractions=On]
\setsansfont{Latin Modern Sans}[Ligatures=TeX,Fractions=On]
\setmonofont{Latin Modern Mono}[Ligatures=TeX,Fractions=On]

%% \hypersetup{bookmarksopen=true,colorlinks=true,allcolors=blue}

%% \setlength{\mathindent}{0pt}

\newcommand{\Rel}{\textbf{Rel}}
\newcommand{\lk}{\(\bar{\lambda}\mu\tilde{\mu}\,\)}

\newcommand{\bnfdef}{\mathbin{::=}}

\DeclareMathOperator{\val}{\textbf{v}}
\DeclareMathOperator{\prd}{\textbf{p}}

\DeclareMathOperator{\coin}{\textbf{tt}}
\DeclareMathOperator{\fst}{\textbf{fst}}
\DeclareMathOperator{\snd}{\textbf{snd}}

\DeclareMathOperator{\pass}{\textbf{pass}}

\DeclareMathOperator{\absurd}{\textbf{absurd}}
\DeclareMathOperator{\inl}{\textbf{inl}}
\DeclareMathOperator{\inr}{\textbf{inr}}

\DeclareMathOperator{\false}{\textbf{false}}
\DeclareMathOperator{\lft}{\textbf{left}}
\DeclareMathOperator{\rgt}{\textbf{right}}

\DeclareMathOperator{\type}{\Box}
\DeclareMathOperator{\prop}{*}

\DeclareMathOperator{\head}{\textbf{head}}
\DeclareMathOperator{\tail}{\textbf{tail}}

\DeclareMathOperator{\Forall}{\textbf{M}}

\DeclareMathOperator{\update}{\leftarrow}

\DeclareMathOperator{\case}{\textbf{match}}

\begin{document}

I wanted to try out making a proof assistant corresponding to the
double category \(\Rel\).

You have a calculus of ``values'' corresponding to one edge of
\(\Rel\) and a sort of relational calculus of ``predicates''
corresponding to the other edge. Squares ought to correspond to
judgements stating a value satisfies a predicate.

The language of ``values'' handling Cartesian product of sets has
product types (in category theory terms is Cartesian.)

The language of ``predicates'' ought to be more complicated. \(\Rel\)
is a closed monoidal category over Cartesian product of sets.  One has
an isomorphism \( \Rel(A, B \otimes C) \sim \Rel (A \otimes B, C) \).
So some sort of substructural type theory ought to be the basic
framework.  I have a hunch explicit unification of logical variables
corresponds to explicit duplication of resources but this is a guess.

This is the core framework.  I've been thinking about further
extensions but I want to see how far I can get characterizing
\(\Rel\) with as few language features as possible.  Later on I
give a few possible extensions.

%% Useful as hell, cite somewhere ?
%% https://tikzcd.yichuanshen.de/


\begin{center}
  \begin{tikzcd}
    \top \arrow{dd}[']{\sigma_p} \arrow{rr}{\sigma_v} & {} \arrow{dd}{v \models p \, [\sigma_v , \sigma_p]} & \times_{x\colon t \val \in \Gamma_v} t \arrow{dd}{v} \\
    &                               &                      \\
    \times_{x\colon t \prd \in \Gamma_p} t \arrow{rr}[']{p}                           & {}                            & t                   
  \end{tikzcd}
\end{center}

\section*{Core Calculus}

\begin{description}[nosep]
\item[Types] \hfill \( t \bnfdef \top \mid t \times t \)
\item[Sorts] \hfill \( s \bnfdef t \prd \mid t \val \)
\item[Values] \hfill \( v \bnfdef x \mid \coin \mid \fst(v) \mid \snd(v) \mid ( v , v ) \)
\item[Predicates] \hfill \( p \bnfdef x \mid \pass(p, p) \mid p \, p \mid \forall (x \colon t \prd) . p \)
\item[Environment] \hfill \( \Gamma \bnfdef \cdot \mid \Gamma , \, x \colon s  \)
\item[Substitutions] \hfill \( \sigma \bnfdef \cdot \mid \sigma , \, v \models x  \)
\end{description}

I need a better name for the abstraction for predicates. It's a little
like the \(\mu\) abstraction from the \lk calculus but different.  I
called it \(\forall\) because it's opposite to application/composition
in \Rel which is existential quantification.

The core calculus is based off multiplicative linear type theory.

Typing judgments.

\begin{multline*}
  \\
  \frac{
  }{
    \Gamma \vdash \coin \colon \top \val
  }\\
  \frac{
    \Gamma \vdash v \colon t_0 \times t_1 \val
  }{
    \Gamma \vdash \fst(v) \colon t_0 \val
  }\\
  \frac{
    \Gamma \vdash v \colon t_0 \times t_1 \val
  }{
    \Gamma \vdash \snd(v) \colon t_1 \val
  }\\
  \frac{
    \Gamma \vdash v_0 \colon t_0 \val \quad
    \Gamma \vdash v_1 \colon t_1 \val
  }{
    \Gamma \vdash ( v_0 , v_1 ) \colon t_0 \times t_1 \val
  }\\
  \frac{
    \Gamma \vdash p_0 \colon \top \prd \quad
    \Delta \vdash p_1 \colon t \prd
  }{
    \Gamma, \, \Delta \vdash \pass(p, p_1) \colon t \prd
  }\\
  \frac{
    \Gamma \vdash p_0 \colon t_0 \times t_1 \prd \quad
    \Delta \vdash p_1 \colon t_0 \prd
  }{
    \Gamma , \, \Delta \vdash p_0 \, p_1 \colon t_1 \prd
  }\\
  \frac{
    \Gamma , \, x \colon t_0 \prd \vdash p \colon t_1 \prd
  }{
    \Gamma \vdash \forall ( x \colon t_0 \prd ) . p \colon t_0 \times t_1 \prd
  }\\
\end{multline*}

When a value satisfies a predicate (I need a better symbol here.)

\begin{multline*}
  \\
\frac{
  v_0 \models p \quad [\sigma]
}{
  \fst ( v_0 , v_1 ) \models p \quad [\sigma]
}\\
\frac{
  v_1 \models p \quad [\sigma]
}{
  \snd ( v_0 , v_1 ) \models p \quad [\sigma]
}\\
\frac{
  v \models \pass(p_0, p_1) \quad [\sigma]
}{
  \coin \models p_0 \; [\sigma]
}\\
\frac{
  v \models [x \update p_1] p_0 \quad [\sigma]
}{
  v \models ( \forall (x \colon t \prd). p_0) \, p_1 \quad [\sigma]
}\\
\frac{
  v_1 \models p \quad [ \sigma , \, v_0 \models x]
}{
  ( v_0 , v_1 ) \models \forall (x \colon t \prd). p \quad [\sigma]
}\\
\end{multline*}

\section*{Examples}

Pattern matching on equality

\begin{multline*}
  \\
   ( v , v ) \models \forall (x \colon t \prd). x\\
\end{multline*}

Transposition

\begin{multline*}
  \\
   \forall (p \colon t \times t \times \top) (x \colon t) (y \colon t). p \, y \, x\\
\end{multline*}

\section*{Disjoint Unions}

Disjoint unions in set become Cartesian product/coproduct in \Rel.

I am fairly confident in a simple extension to disjoint unions
of sets which are sum types in the value calculus and product types in
the predicate calculus.

\begin{description}[nosep]
\item[Types] \hfill \( t \bnfdef \ldots \mid \bot \mid t + t \)
\item[Values] \hfill \( v \bnfdef \ldots \mid \absurd_t(v) \mid \inl_t(v) \mid \inr_t(v) \mid
  \case \, v \,
  \begin{cases}
    v & \leftarrow \inl(x) \\
    v & \leftarrow \inr(x)
  \end{cases}
  \)
\item[Predicates] \hfill \( p \bnfdef \ldots \mid \false \mid \lft(p) \mid \rgt(p) \mid [ p ; p ] \)
\end{description}

Typing judgments.

\begin{multline*}
  \\
\frac{
  \Gamma \vdash v \colon \bot \val
}{
  \Gamma \vdash \absurd_t(v) \colon t \val
}\\
\frac{
  \Gamma \vdash v \colon t_0 \val
}{
  \Gamma \vdash \inl_{t_1}(v) \colon t_0 + t_1 \val
}\\
\frac{
  \Gamma \vdash v \colon t_1 \val
}{
  \Gamma \vdash \inr_{t_0}(v) \colon t_0 + t_1 \val
}\\
\frac{
  \Gamma \vdash v_0 \colon t_0 + t_1 \val \;
  \Gamma , \, x_0 \colon t_0 \val \vdash v_1 \colon t_2 \val \;
  \Gamma , \, x_1 \colon t_1 \val \vdash v_2 \colon t_2 \val
}{
  \Gamma \vdash
  \case \, v_0 \,
  \begin{cases}
   v_1 & \leftarrow \inl(x_0) \\
   v_2 & \leftarrow \inr(x_1)
  \end{cases}
  \colon t_2 \val
}\\
\frac{
}{
  \Gamma \vdash \false \colon \bot \prd
}\\
\frac{
  \Gamma \vdash p \colon t_0 + t_1 \prd
}{
  \Gamma \vdash \lft(p) \colon t_0 \prd
}\\
\frac{
  \Gamma \vdash p \colon t_0 + t_1 \prd
}{
  \Gamma \vdash \rgt(p) \colon t_1 \prd
}\\
\frac{
  \Gamma \vdash p_0 \colon t_0 \prd \quad
  \Gamma \vdash p_1 \colon t_1 \prd
}{
  \Gamma \vdash [ p_0 ; p_1 ] \colon t_0 + t_1 \prd
}\\
\end{multline*}

Satisfies

\begin{multline*}
  \\
\frac{
  [x_0 \update v_0] v_1 \models p \quad [\sigma]
}{
  \case \, \inl_t(v_0) \,
  \begin{cases}
    v_1 & \leftarrow \inl(x_0) \\
    v_2 & \leftarrow \inr(x_1)
  \end{cases}
 \models p \; [\sigma]
}\\
\frac{
  [x_1 \update v_0] v_2 \models p \quad [\sigma]
}{
  \case \, \inr_t(v_0) \,
  \begin{cases}
    v_1 & \leftarrow \inl(x_0) \\
    v_2 & \leftarrow \inr(x_1)
  \end{cases}
  \models p \; [\sigma]
}\\
\frac{
  v \models p_0 \; [\sigma]
}{
  v \models \lft([ p_0 ; p_1 ]) \quad [\sigma]
}\\
\frac{
  v \models p_1 \; [\sigma]
}{
  v \models \rgt([ p_0 ; p_1 ]) \quad [\sigma]
}\\
\frac{
  \absurd_t(v) \models p \quad [\sigma]
}{
  v \models \false \; [\sigma]
}\\
\frac{
  v \models p_0 \; [\sigma]
}{
  \inl_t(v) \models [ p_0 ; p_1 ] \quad [\sigma]
}\\
\frac{
  v \models p_1 \; [\sigma]
}{
  \inr_t(v) \models [ p_0 ; p_1 ] \quad [\sigma]
}\\
\end{multline*}

\section*{Dependent Sums}

If product of sets becomes an internal hom in the predicate calculus
then dependent sums ought to become a little like \(\Pi\) types.  So
the predicate calculus effectively becomes like System-F.

Some things become awkward to interpret here though.

I also really can't figure out unpacking. It's messy if you don't want
full dependent types.

\begin{description}[nosep]
\item[Types] \hfill \( t \bnfdef \ldots \mid x \mid \head(v) \mid \Sigma (x \colon \prop). t \)
\item[Sorts] \hfill \( s \bnfdef \ldots \mid \prop \)
\item[Values] \hfill \( v \bnfdef \ldots \mid \tail(v) \mid \langle x \update t , v \rangle \)
\item[Predicates] \hfill \( p \bnfdef \ldots \mid p \, t \mid \Forall (x \colon \prop). p \)
\item[Substitutions] \hfill \( \sigma \bnfdef \ldots \mid \sigma , \, t \models x \)
\end{description}

Not really good at the typing judgements for dependent sum types.

\begin{multline*}
  \\
\frac{
  \Gamma \vdash v \colon \Sigma (x \colon \prop). t \val
}{
  \Gamma \vdash \head(v) \colon \prop
}\\
\frac{
  \Gamma \vdash v \colon \Sigma (x \colon \prop). t \val
}{
  \Gamma \vdash \tail(v) \colon [x \update \head(v)] t \val
}\\
\frac{
  \Gamma \vdash t_0 \colon \prop \quad
  \Gamma , \, x \colon \prop \vdash v \colon t_1 \val
}{
  \Gamma \vdash \langle x \update t_0 , v \rangle \colon \Sigma (x \colon \prop). t_0 \val
}\\
\frac{
  \Gamma \vdash p \colon \Sigma (x\colon \prop). t_1 \prd \quad
  \Gamma \vdash t_0 \colon \prop
}{
  \Gamma \vdash p_0 \, t_0 \colon [x \update t_0] t_1 \prd
}\\
\frac{
  \Gamma , \, x \colon \prop \vdash p \colon t \prd
}{
  \Gamma \vdash \Forall (x \colon \prop). p \colon \Sigma (x\colon \prop). t \prd
}\\
\end{multline*}

I can't figure out satisfaction at all.

\begin{multline*}
  \\
\frac{
  t \models p \quad [\sigma]
}{
  \head(\langle x \update t , v \rangle) \models p \quad [\sigma]
}\\
\frac{
  [x \update t] v \models p \quad [\sigma]
}{
  \tail(\langle x \update t , v \rangle) \models p \quad [\sigma]
}\\
\frac{
  v \models [x \update t] p \quad [\sigma]
}{
  v \models ( \textbf{M} (x \colon \prop). p) \, t \quad [\sigma]
}\\
\frac{
  v \models p \; [ \sigma , \, t \models x]
}{
  \langle x \update t , v \rangle \models \Forall (x \colon \prop). p \quad [\sigma]
}\\
\end{multline*}

\section*{The Future?}

Satisifies judgments correspond to thin squares. Moving to more
generally categories such as \textbf{Span} or \textbf{Prof} or
\textbf{Vect} for matrix math requires an interpretation of squares
carrying constructive content.

\end{document}
