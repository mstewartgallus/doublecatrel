% Formatting
\documentclass{scrartcl}

%% Fixers
\usepackage{fontspec}
\usepackage{realscripts}
\usepackage{xunicode}
\usepackage{polyglossia}

\usepackage[]{microtype}
%% \usepackage[top=0.7in, bottom=0.7in, left=0.6in, right=0.6in]{geometry}
\usepackage[english]{isodate}

% Packages
\usepackage{lastpage}
\usepackage{scrlayer-scrpage}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bussproofs}
\usepackage{stmaryrd}

\usepackage{tikz}
\usepackage{tikz-cd}

%Load Last Fixers

% Settings

\setdefaultlanguage{english}
\setotherlanguage{latin}

\setmainfont{Latin Modern Roman}[Ligatures=TeX,Fractions=On]
\setsansfont{Latin Modern Sans}[Ligatures=TeX,Fractions=On]
\setmonofont{Latin Modern Mono}[Ligatures=TeX,Fractions=On]

%% \hypersetup{bookmarksopen=true,colorlinks=true,allcolors=blue}

%% \setlength{\mathindent}{0pt}

\newcommand{\Rel}{\textbf{Rel}}
\newcommand{\Set}{\textbf{Set}}
\newcommand{\Span}{\textbf{Span}}
\newcommand{\Vect}{\textbf{Vect}}
\newcommand{\Prof}{\textbf{Prof}}
\newcommand{\lk}{\(\bar{\lambda}\mu\tilde{\mu}\,\)}

\newcommand{\name}[1]{\LeftLabel{\fbox{#1}}}
\newcommand{\side}[1]{\RightLabel{\scriptsize{\(\left\{#1\right\}\)}}}

\newcommand{\taut}{\AxiomC{\(\top\)}}
\newcommand{\bnfdef}{\mathrel{::=}}

\newcommand{\step}{\mathrel{\rightsquigarrow}}
\newcommand{\with}{\;}
\newcommand{\sat}{\mathbin{\otimes}}

\def\fCenter{\mathrel{\vdash}}

\newcommand{\axiom}[2]{\fbox{#1}~#2}

%% \newcommand{\axiom}[2]{\begin{prooftree}\name{#1}\AxiomC{\(\top\)}\UnaryInfC{#2}\end{prooftree}}

\DeclareMathOperator{\val}{\textbf{v}}
\DeclareMathOperator{\prd}{\textbf{p}}

\DeclareMathOperator{\unit}{\top}
\DeclareMathOperator{\mt}{\emptyset}
\DeclareMathOperator{\coin}{\textbf{!}}
\DeclareMathOperator{\fst}{\pi_1}
\DeclareMathOperator{\snd}{\pi_2}

\DeclareMathOperator{\success}{\textbf{true}}
\newcommand{\pass}{\mathbin{\gg}}

\DeclareMathOperator{\absurd}{\textbf{abort}}
\DeclareMathOperator{\inl}{\textbf{i}_1}
\DeclareMathOperator{\inr}{\textbf{i}_2}

\DeclareMathOperator{\false}{\textbf{false}}
\DeclareMathOperator{\lft}{\textbf{l}}
\DeclareMathOperator{\rgt}{\textbf{r}}

\DeclareMathOperator{\type}{\Box}
\DeclareMathOperator{\prop}{*}
\newcommand{\Type}{\textbf{Type}}

\DeclareMathOperator{\head}{\textbf{h}}
\DeclareMathOperator{\tail}{\textbf{t}}

\newcommand{\Forall}{\Pi}

\newcommand{\update}{\mathbin{:=}}

\DeclareMathOperator{\case}{\textbf{m}}

\begin{document}

\title{Internal Language of Rel}
\author{Molly Stewart-Gallus}

\maketitle

I wanted an internal language corresponding to the double category
\Rel{}. Recall \Rel{} is the double category with sets as objects,
relations as horizontal arrows and functions as vertical arrows.

I present three different calculi: a substructural ``context
calculus'' corresponding to the horizontal edge of \Rel{}; a ``term
calculus'' corresponding to \Set{}, the vertical edge category of
\Rel{}; and a simple ``command'' calculus encoding commuting squares
of \Rel{}.

First, I give the basic framework of the calculi. Then I discuss
semantics and applications. And later I list a few possible extensions
such as coproduct and depedent sum types.

\section*{Core Calculi}

The core context calculus is the linear lambda calculus with a few
symbol changes and models the closed monoidal structure of the
horizontal edge of \Rel{}.

The core term calculus is a little language with only product types
and models the Cartesian structure of \Set{}.

The core command calculus models commuting squares in \Rel{}.


\begin{center}

\[\begin{aligned}
&\textbf{Types} &  t & \bnfdef \prop \mid t \times t  \\
&\textbf{Contexts}  & E & \bnfdef x_t \mid E \, E \mid \forall (x \colon t) . E  \\
&\textbf{Terms} &  v & \bnfdef x \mid \fst(v) \mid \snd(v) \mid v , v  \\
&\textbf{Environment}  &  \Gamma & \bnfdef \cdot \mid \Gamma , \, x \colon t   \\
&\textbf{Command Env}  &  \Delta & \bnfdef \cdot \mid \Delta , \, x \mid v  
\end{aligned}\]


\subsubsection*{Context Calculus}

\axiom{V}
      {\(\cdot , \, x \colon t \vdash x_t \colon t\)}

      
\begin{prooftree}
\name{\(\times\)I}
\Axiom$\Gamma \fCenter E \colon t_1$
\side{ x \colon t_0 \in \Gamma }
\UnaryInf$\Gamma \setminus x \fCenter \forall (x \colon t_0). E \colon t_0 \times t_1$
\end{prooftree}

\begin{prooftree}
\name{\(\times\)E}
\Axiom$\Gamma_0 \fCenter E_0 \colon t_0 \times t_1$
\Axiom$\Gamma_1 \fCenter E_1 \colon t_0$
\BinaryInf$\Gamma_0, \, \Gamma_1 \fCenter E_0 \, E_1 \colon t_1$
\end{prooftree}

\axiom{\(\times\beta\)}
      {\( ( \forall (x \colon t ). E_0) \, E_1 \step [x_t \update E_1] E_0 \)}

\subsubsection*{Term Calculus}

\begin{prooftree}
\name{V}
\AxiomC{\(x \colon t \in \Gamma\)}
\UnaryInf$\Gamma \fCenter x \colon t$
\end{prooftree}

\begin{prooftree}
\name{\(\times\)I}
\Axiom$\Gamma \fCenter v_0 \colon t_0$
\Axiom$\Gamma \fCenter v_1 \colon t_1$
\BinaryInf$\Gamma \fCenter v_0, v_1 \colon t_0 \times t_1$
\end{prooftree}

{\name{\(\times\text{E}_1\)}
\Axiom$\Gamma \fCenter v \colon t_0 \times t_1$
\UnaryInf$\Gamma \fCenter \fst(v) \colon t_0$
\DisplayProof
\hfill
\name{\(\times\text{E}_2\)}
\Axiom$\Gamma \fCenter v \colon t_0 \times t_1$
\UnaryInf$\Gamma \fCenter \snd(v) \colon t_1$
\DisplayProof}

{\axiom{\(\times\beta_1\)}
       {\(\fst (v_0 , v_1 ) \step v_0 \)}
\hfill
\axiom{\(\times\beta_2\)}
      {\(\snd (v_0 , v_1 ) \step v_1 \)}
}

\subsubsection*{Command Calculus}

\axiom{V}
      {\(\cdot , \, x_t \sat v  \fCenter  x_t \sat v \)}

{\name{v}
\Axiom$\Delta \fCenter E \sat v_0$
\AxiomC{\(v_0 \step v_1\)}
\BinaryInf$\Delta \fCenter E \sat v_1$
\DisplayProof
\hfill
\name{E}
\Axiom$\Delta \fCenter E_0 \sat v$
\AxiomC{\(E_0 \step E_1\)}
\BinaryInf$\Delta \fCenter E_1 \sat v$
\DisplayProof}

\begin{prooftree}
\name{\(\times\)I}
\Axiom$ \Delta , \,  x_t \sat v_0  \fCenter E \sat v_1 $
\UnaryInf$ \Delta \fCenter \forall (x \colon t ). E \sat  v_0 , v_1 $
\end{prooftree}


\begin{prooftree}
\name{\(\times\)E}
\Axiom$ \Delta_0 \fCenter \forall (x \colon t). E_0 \sat v_0 , v_1 $
\Axiom$ \Delta_1 \fCenter E_1 \sat v_0 $
\BinaryInf$ \Delta_0 , \, \Delta_1 \fCenter [ x \update E_1 ] E_0 \sat v_1 $
\end{prooftree}


\end{center}

The context calculus has a linear variable rule.  To make
mechanization easier linear variables are explicitly indexed by their
types and variable binding is more imperative and so ensuring the
typing environment can be directly inferred from context expressions.

\section*{Discussion}

%% Technical choices

%% I decided against rules for mapping from \Set{} to \Rel{} because I wanted
%% to see how far \Rel{} could go on its own and also wanted to see if
%% these could be defined later.

\subsection*{Examples}

\noindent Identity:

\begin{prooftree}
  \taut
  \RightLabel{\scriptsize{(V)}}
  \UnaryInf$ \Delta , \,  x_t \sat v  \fCenter  x_t \sat v $
  \RightLabel{\scriptsize{(\(\times\)I)}}
  \UnaryInf$ \Delta \fCenter  \forall (x \colon t). x_t  \sat v , v $

\end{prooftree}

\noindent Transposition:

\[ \textbf{trans} = \forall (p \colon t_0 \times t_1 \times t_2) (x \colon t_1) (y \colon t_0). p_{(t_0 \times t_1 \times t_2)} \, y_t \, x_t \]

\section*{Categorical Semantics}
%% Useful as hell, cite somewhere ?
%% https://tikzcd.yichuanshen.de/

The intent is to create calculi encoding the core features of the
double category \Rel{}.

If this is successful then terms and types ought to map to \Rel{} as
follows.

I think you want pullbacks for the environment arrows?

\begin{center}
  \begin{tikzcd}
   ? \arrow{dd}[']{?} \arrow{rr}{?} & {} \arrow[Rightarrow]{dd}{\Delta \fCenter E \sat v} & \times_{x\colon t \in \Gamma_v} t \arrow{dd}{v} \\
    &                               &                      \\
    \times_{x\colon t \in \Gamma_E} t \arrow{rr}[']{E}                           & {}                            & t                   
  \end{tikzcd}
\end{center}

I have no idea about universe issues and such. Dependent sum is probably wrong.

Really need to think about denotation again.

\[
\begin{aligned}
  \llbracket t_0 \times t_1 \rrbracket & =\llbracket t_0 \rrbracket \times \llbracket t_1 \rrbracket \\
  \\
  \llbracket x \rrbracket(\sigma) & = \sigma(x) \\
  \llbracket v_0 , v_1 \rrbracket(\sigma) & =( \llbracket v_0 \rrbracket(\sigma) , \llbracket v_1 \rrbracket(\sigma) ) \\
  \\
  \llbracket x_t \rrbracket(\sigma, s) & = \sigma(x, s) \\
  \llbracket E_0 \, E_1 \rrbracket(\sigma, s_0) & = \exists s_1,  \llbracket E_1 \rrbracket (\sigma, s_1) \wedge \llbracket E_0 \rrbracket (\sigma, (s_1, s_0))\\
  \llbracket \forall (x \colon t). E_0 \rrbracket(\sigma, (s_0, s_1)) & = \forall E_1, \llbracket E_1 \rrbracket (\sigma, s_0) \rightarrow \llbracket E_0 \rrbracket ([x \update  s \mapsto \llbracket E_1 \rrbracket(\sigma, s)] \sigma, s_1) 
\end{aligned}
\]

\section*{Synthetic Category Theory}

A category is a monad in \Span{}.  Once this system has been generalized
to \Span{} we can define monads internal to \Span{}.

This is not fully internal but a simple approach to defining an
equivalence relation might be something like:

\begin{center}

{\axiom{object}{\( \cdot \fCenter O \colon \prop \)}\hfill
\axiom{arrow}{\( \cdot \fCenter R \colon O \times O \)}}

\name{refl}
\Axiom$\cdot \fCenter o \colon O$
\UnaryInf$\cdot \fCenter R \sat o, o $
\DisplayProof

\name{trans}
\Axiom$ \cdot \fCenter  \forall (x\colon O). R \, (R \, x)  \sat o_0, o_1 $
\side{\cdot \fCenter o_1, o_0 \colon O \times O}
\UnaryInf$ \cdot \fCenter  R \sat o_0, o_1 $
\DisplayProof

\name{sym}
\Axiom$ \cdot \fCenter  R \sat o_0, o_1  $
\side{\cdot \fCenter o_1, o_0 \colon O \times O}
\UnaryInf$ \cdot \fCenter  R \sat o_1, o_0 $
\DisplayProof
      
\end{center}

Generalizing to a constructive interpretation in terms of spans and
groupoids is future work.

\section*{Unit Type}

\begin{center}

\[\begin{aligned}
&\textbf{Types} &  t & \bnfdef \ldots \mid 1  \\
&\textbf{Contexts}  & E & \bnfdef \ldots \mid \success \mid E \pass E  \\
&\textbf{Terms} &  v & \bnfdef \ldots \mid \coin 
\end{aligned}\]

\subsubsection*{Context Calculus}

{\axiom{\(\unit\)I}
      {\(\cdot \vdash \success \colon \unit\)}
\hfill
\begin{prooftree}
\name{\(\unit\)E}
\Axiom$\Gamma_0 \fCenter p_0 \colon \unit$
\Axiom$\Gamma_1 \fCenter p_1 \colon t$
\BinaryInf$\Gamma_0, \, \Gamma_1 \fCenter E_0 \pass E_1 \colon t$
\end{prooftree}}

\axiom{\(\unit\beta\)}
      {\(\success \pass E \step E \)}

\subsubsection*{Term Calculus}

\axiom{\(\unit\)I}
      {\(\Gamma \fCenter \coin \colon \unit \)}

\subsubsection*{Command Calculus}

\axiom{\(\unit\)I}
      {\(\cdot \fCenter \success \sat \coin \)}

\begin{prooftree}
\name{\(\unit\)E}
\Axiom$ \Delta_0 \fCenter \success \sat \coin $
\Axiom$ \Delta_1 \fCenter E \sat v $
\BinaryInf$ \Delta_0 , \, \Delta_1 \fCenter E \sat v $
\end{prooftree}

\end{center}

\section*{Disjoint Unions}

Disjoint unions in \Set{} become Cartesian products/coproducts in
\Rel{}.

%% I have a hunch it is proper for the combination of product/coproduct
%% to introduce nondeterminism in the operational semantics but I need to
%% think more about the issue.

As a technical hack \(\false\) is explicitly indexed by the environment it ignores.
This hack also requires inferring the environment in certain reduction rules.

\begin{center}

\[\begin{aligned}
& \textbf{Types} & t & \bnfdef \ldots \mid \mt \mid t + t \\
& \textbf{Contexts} & E & \bnfdef \ldots \mid
  \absurd_t(E) \mid \inl_t(E) \mid \inr_t(E) \mid \\
&                     & & \case(v, E. v, x. E) \mid \false_\Gamma \mid \lft(E) \mid \rgt(E) \mid E ; E  \\
& \textbf{Terms} & v & \bnfdef \ldots \mid \absurd_t(v) \mid \inl_t(v) \mid \inr_t(v) \mid
  \case(v, x. v, x. v)
\end{aligned}\]

\subsubsection*{Context Calculus}

\name{\(\mt\text{E}^\text{T}\)}
\Axiom$\Gamma \fCenter E \colon \mt$
\UnaryInf$\Gamma \fCenter \absurd_t(E) \colon t$
\DisplayProof

{\name{\(+\text{I}^\text{T}_1\)}
\Axiom$\Gamma \fCenter E \colon t_0$
\UnaryInf$\Gamma \fCenter \inl_{t_1}(E) \colon t_0 + t_1$
\DisplayProof
\hfill
\name{\(+\text{I}^\text{T}_2\)}
\Axiom$\Gamma \fCenter E \colon t_1$
\UnaryInf$\Gamma \fCenter \inr_{t_0}(E) \colon t_0 + t_1$
\DisplayProof}

\name{\(+\text{E}^\text{T}\)}
\Axiom$ \Gamma \fCenter E_0 \colon t_0 + t_1 $
\Axiom$ \Gamma , \, x_0 \colon t_0 \fCenter E_1 \colon t_2 $
\Axiom$ \Gamma , \, x_1 \colon t_1 \fCenter E_1 \colon t_2 $
\TrinaryInf$ \Gamma \fCenter \case(E_0, x_0. E_1, x_1. E_2) \colon t_2 $
\DisplayProof

\axiom{\(\mt\)I}
      {\( \Gamma \fCenter \false_\Gamma \colon \mt \)}

{\name{\(+\text{E}_1\)}
\Axiom$\Gamma \fCenter E \colon t_0 + t_1$
\UnaryInf$\Gamma \fCenter \lft(E) \colon t_0$
\DisplayProof
\hfill
\name{\(+\text{E}_2\)}
\Axiom$\Gamma \fCenter E \colon t_0 + t_1$
\UnaryInf$\Gamma \fCenter \rgt(E) \colon t_1)$
\DisplayProof
}

\name{\(+\)I}
\Axiom$ \Gamma \fCenter E_0 \colon t_0 $
\Axiom$ \Gamma \fCenter E_1 \colon t_1 $
\BinaryInf$ \Gamma \fCenter E_0 ; E_1 \colon t_0 + t_1 $
\DisplayProof

\axiom{\(+\beta^\text{T}_1\)}
      {\(
  \case(\inl_t(E_0), x_0. E_1, x_1. E_2) \step [x_0 \update E_0] E_1
  \)}

\axiom{\(+\beta^\text{T}_2\)}
      {\(
  \case(\inr_t(E_0), x_0. E_1, x_1. E_2) \step [x_1 \update E_0] E_2
  \)}

{\axiom{\(+\beta_1\)}{\( \lft(E_0 ; E_1) \step E_0 \)}
\hfill
\axiom{\(+\beta_2\)}{\( \rgt(E_0 ; E_1) \step E_1 \)}}

{
\axiom{\(+\beta\beta^\text{T}_1\)}
      {\( \lft(\inl_t(E)) \step E \)}
\hfill
\axiom{\(+\beta\beta^\text{T}_2\)}
      {\( \rgt(\inr_t(E)) \step E \)}
}

{\name{\(+\text{R}\text{R}^\text{T}_3\)}
\Axiom$\Gamma \fCenter E \colon t$
\UnaryInfC{\(\lft(\inr_t(E)) \step \absurd_t(\false_\Gamma)\)}
\DisplayProof
\hfill
\name{\(+\text{R}\text{R}^\text{T}_4\)}
\Axiom$\Gamma \fCenter E \colon t$
\UnaryInfC{\(\rgt(\inl_t(E)) \step \absurd_t(\false_\Gamma)\)}
\DisplayProof
}

\axiom{\(+\text{R}^\text{T}\text{R}_1\)}
      {\(\case(E_0 ; E_1, x_0. E_2, x_1. E_3) \step [x_0 := E_0] E_2\)}

\axiom{\(+\text{R}^\text{T}\text{R}_2\)}
      {\( \case(E_0 ; E_1, x_0. E_2, x_1. E_3) \step [x_1 := E_1] E_3 \)}

\subsubsection*{Term Calculus}

\name{\(\mt\)E}
\Axiom$\Gamma \fCenter v \colon \mt$
\UnaryInf$\Gamma \fCenter \absurd_t(v) \colon t$
\DisplayProof

{\name{\(+\text{I}_1\)}
\Axiom$\Gamma \fCenter v \colon t_0$
\UnaryInf$\Gamma \fCenter \inl_{t_1}(v) \colon t_0 + t_1$
\DisplayProof
\hfill
\name{\(+\text{I}_2\)}
\Axiom$\Gamma \fCenter v \colon t_1$
\UnaryInf$\Gamma \fCenter \inr_{t_0}(v) \colon t_0 + t_1$
\DisplayProof
}

\name{\(+\)E}
\Axiom$ \Gamma \fCenter v_0 \colon t_0 + t_1 $
\Axiom$ \Gamma , \, x_0 \colon t_0 \fCenter v_1 \colon t_2 $
\Axiom$ \Gamma , \, x_1 \colon t_1 \fCenter v_1 \colon t_2 $
\TrinaryInf$ \Gamma \fCenter \case(v_0, x_0. v_1, x_1. v_2) \colon t_2 $
\DisplayProof

\axiom{\(+\beta_1\)}
      {\( \case(\inl_t(v_0), x_0. v_1, x_1. v_2) \step [x_0 \update v_0] v_1 \)}

\axiom{\(+\beta_2\)}
      {\( \case(\inr_t(v_0), x_0. v_1, x_1. v_2) \step [x_1 \update v_0] v_2 \)}

\subsubsection*{Command Calculus}

{\name{\(+\text{I}_1\)}
\Axiom$\Delta \fCenter E_0 \sat v $
\UnaryInf$\Delta \fCenter E_0 ; E_1 \sat \inl_t(v) $
\DisplayProof
\hfill
\name{\(+\text{I}_2\)}
\Axiom$\Delta \fCenter  E_1 \sat v$
\UnaryInf$\Delta \fCenter  E_0 ; E_1 \sat \inr_t(v) $
\DisplayProof
}

\name{\(\mt\)I}
\Axiom$\Delta \fCenter E \sat \absurd_t(v) $
\UnaryInf$\Delta \fCenter \false_\Gamma \sat v $
\DisplayProof

\end{center}

\section*{Dependent Sums}

If product of sets becomes an internal hom in the predicate calculus
then dependent sums ought to become a little like \(\Pi\) types.  So
the predicate calculus effectively becomes like a linear System-F.

Some things become awkward to interpret here though.

I also really can't figure out unpacking. It's messy if you don't want
full dependent types.

Not really good at the typing judgements for dependent sum types.

\begin{center}

\[\begin{aligned}
& \textbf{Types} & t & \bnfdef \ldots \mid x \mid \prop \mid \head(v) \mid \Sigma (x \colon \prop). t  \\
& \textbf{Contexts} &  E & \bnfdef \ldots \mid E \, t \mid \Forall (x \colon \prop). E  \\
& \textbf{Terms} &  v & \bnfdef \ldots \mid \tail(v) \mid \langle x \update t , v \rangle  \\
& \textbf{Command Env} & \Delta & \bnfdef \ldots \mid \Delta , \, x \sat t 
\end{aligned}\]

\subsubsection*{Context Calculus}

\name{\(\Sigma\)E}
\Axiom$ \Gamma_0 \fCenter E \colon \Sigma (x\colon \prop). t_1 $
\Axiom$ \Gamma_1 \fCenter t_0 \colon \prop $
\BinaryInf$ \Gamma_0, \, \Gamma_1 \fCenter E_0 \, t_0 \colon [x \update t_0] t_1 $
\DisplayProof

\name{\(\Sigma\)I}
\Axiom$ \Gamma , \, x \colon \prop \fCenter E \colon t $
\UnaryInf$ \Gamma \fCenter \Forall (x \colon \prop). E \colon \Sigma (x \colon \prop). t $
\DisplayProof

\axiom{\(\Sigma\beta\)}{\( ( \Forall (x \colon \prop). E) \, t \step [x \update t] E \)}

\subsubsection*{Term Calculus}

%% \axiom{U}
%%       {\(\Gamma \fCenter U_i \, \Type\)}

%% \name{U}
%% \Axiom$\Gamma \fCenter v \colon U_i$
%% \UnaryInf$\Gamma \fCenter \llbracket v \rrbracket \, \Type$
%% \DisplayProof

%% \axiom{U}
%%       {\(\Gamma \fCenter u_i : U_{i+1} \)}

%% \name{U}
%% \Axiom$\Gamma \fCenter v \colon U_i$
%% \UnaryInf$\Gamma \fCenter \llbracket v \rrbracket \, \Type$
%% \DisplayProof

\name{\(\Sigma\text{E}_1\)}
\Axiom$\Gamma \fCenter E \colon \Sigma (x \colon \prop). t$
\UnaryInf$\Gamma \fCenter \head(v) \colon \prop$
\DisplayProof

\name{\(\Sigma\text{E}_2\)}
\Axiom$\Gamma \fCenter v \colon \Sigma (x \colon \prop). t$
\UnaryInf$\Gamma \fCenter \tail(v) \colon [x \update \head(v)] t$
\DisplayProof

\name{\(\Sigma\)I}
\Axiom$ \Gamma \fCenter t_0 \colon \prop $
\Axiom$ \Gamma , \, x \colon \prop \fCenter v \colon t_1 $
\BinaryInf$\Gamma \fCenter \langle x \update t_0 , v \rangle \colon \Sigma (x \colon \prop). t_0 $
\DisplayProof

{\axiom{\(\Sigma\beta_1\)}{\( \head(\langle x \update t , v \rangle) \step t \)}
\hfill
\axiom{\(\Sigma\beta_2\)}{\( \tail( \langle x \update t , v \rangle) \step [x \update t] v \)}
}

\subsubsection*{Command Calculus}

\name{\(\Sigma\)I}
\Axiom$ \Delta , \,  x \sat t  \fCenter E \sat v $
\UnaryInf$ \Delta \fCenter  \Forall (x \colon \prop). E \sat \langle x \update t , v \rangle $
\DisplayProof

\end{center}

I can't figure out commands here at all.

\section*{The Future?}

Satisifies judgments correspond to thin squares. Moving to more
general categories such as \Span{} or \Prof{} or
\Vect{} for matrix math requires an interpretation of squares
carrying constructive content.

\end{document}
