% Formatting
\documentclass[twocolumn]{scrartcl}

%% Fixers
\usepackage{fontspec}
\usepackage{realscripts}
\usepackage{xunicode}
\usepackage{polyglossia}

\usepackage[]{microtype}
\usepackage[top=0.7in, bottom=0.7in, left=0.7in, right=0.7in]{geometry}
\usepackage[english]{isodate}

% Packages
\usepackage{lastpage}
\usepackage{scrlayer-scrpage}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bussproofs}
\usepackage{stmaryrd}

\usepackage{tikz}
\usepackage{tikz-cd}

%Load Last Fixers

% Settings

\setdefaultlanguage{english}
\setotherlanguage{latin}

\setmainfont{Latin Modern Roman}[Ligatures=TeX,Fractions=On]
\setsansfont{Latin Modern Sans}[Ligatures=TeX,Fractions=On]
\setmonofont{Latin Modern Mono}[Ligatures=TeX,Fractions=On]

%% \hypersetup{bookmarksopen=true,colorlinks=true,allcolors=blue}

%% \setlength{\mathindent}{0pt}

\newcommand{\Rel}{\textbf{Rel}}
\newcommand{\Set}{\textbf{Set}}
\newcommand{\lk}{\(\bar{\lambda}\mu\tilde{\mu}\,\)}

\newcommand{\name}[1]{\LeftLabel{\fbox{#1}}}

\newcommand{\taut}{\AxiomC{\(\top\)}}
\newcommand{\bnfdef}{\mathrel{::=}}

\newcommand{\step}{\mathrel{\rightsquigarrow}}
\newcommand{\with}{\;}

\newcommand{\axiom}[2]{\fbox{#1}~#2}
\newcommand{\judge}[3]{
  \AxiomC{\(#2\)}
  \name{#1}
  \UnaryInfC{\(#3\)}
  \DisplayProof
}
\newcommand{\bijudge}[4]{
  \AxiomC{#2}
  \AxiomC{#3}
  \name{#1}
  \BinaryInfC{#4}
  \DisplayProof
}
\newcommand{\trijudge}[5]{
  \AxiomC{#2}
  \AxiomC{#3}
  \AxiomC{#4}
  \name{#1}
  \TrinaryInfC{#5}
  \DisplayProof
}

\DeclareMathOperator{\val}{\textbf{v}}
\DeclareMathOperator{\prd}{\textbf{p}}

\DeclareMathOperator{\unit}{\top}
\DeclareMathOperator{\mt}{\emptyset}
\DeclareMathOperator{\coin}{\textbf{!}}
\DeclareMathOperator{\fst}{\pi_1}
\DeclareMathOperator{\snd}{\pi_2}

\DeclareMathOperator{\success}{\textbf{success}}
\newcommand{\pass}{;}

\DeclareMathOperator{\absurd}{\textbf{abort}}
\DeclareMathOperator{\inl}{\textbf{i}_1}
\DeclareMathOperator{\inr}{\textbf{i}_2}

\DeclareMathOperator{\false}{\textbf{fail}}
\DeclareMathOperator{\lft}{\textbf{l}}
\DeclareMathOperator{\rgt}{\textbf{r}}

\DeclareMathOperator{\type}{\Box}
\DeclareMathOperator{\prop}{*}

\DeclareMathOperator{\head}{\textbf{h}}
\DeclareMathOperator{\tail}{\textbf{t}}

\newcommand{\Forall}{\Pi}

\newcommand{\update}{\mathbin{:=}}

\DeclareMathOperator{\case}{\textbf{m}}

\begin{document}

I wanted to try figuring out a sort of internal language corresponding
to the double category \Rel.

You have a calculus of ``values'' corresponding to the \Set edge of
\Rel and a sort of relational calculus of ``predicates'' corresponding
to the other edge. Squares ought to correspond to judgements stating a
value satisfies a predicate.

The language of ``values'' handling Cartesian product of sets has
product types (in category theory terms is Cartesian.)

The language of ``predicates'' ought to be more complicated. \Rel
is a closed monoidal category over Cartesian product of sets.  One has
an isomorphism \( \Rel(A, B \otimes C) \sim \Rel (A \otimes B, C) \).
So some sort of linear type theory is required.

This is the core framework.  I've been thinking about further
extensions but I want to see how far I can get characterizing
\Rel with as few language features as possible.  Later on I
give a few possible extensions.

\section*{Core Calculi}

\begin{description}[nosep]
\item[Types] \hfill \( t \bnfdef \unit \mid t \times t \)
\item[Values] \hfill \( v \bnfdef x \mid \coin \mid \fst(v) \mid \snd(v) \mid ( v , v ) \)
\item[Predicates] \hfill \( p \bnfdef x_t \mid \success \mid p \pass p \mid p \, p \mid \forall (x \colon t) . p \)
\item[Environment] \hfill \( \Gamma \bnfdef \cdot \mid \Gamma , \, x \colon t  \)
\item[Substitutions] \hfill \( \sigma \bnfdef \cdot \mid \sigma , \, v \models x  \)
\end{description}

The core relational calculus is the linear lambda calculus with a few
symbol changes.  The core value calculus has only product types.

I'm not really sure small steps semantics make sense with respect to
the relational calculus but the value calculus corresponding to \Set
ought to have simple deterministic semantics.

\subsubsection*{Relational Calculus}

The relational calculus has a linear variable rule.  As a hack to make
mechanization easier linear variables are explicitly indexed by their
types.

\begin{flushleft}

\judge{V}
      {x \colon t \in \Gamma}
      {\cdot , \, x \colon t \vdash x_t \colon t}

\axiom{\(\unit\)I}
      {\(\cdot \vdash \success \colon \unit\)}

\bijudge{\(\unit\)E}
        {\(\Gamma \vdash p_0 \colon \unit \)}
        {\(\Delta \vdash p_1 \colon t \)}
        {\(\Gamma, \, \Delta \vdash p_0 \pass p_1 \colon t\)}
  
\judge{\(\times\)I}
      {\Gamma, x \colon t_0 \vdash p \colon t_1}
      {\Gamma \vdash \forall (x \colon t_0). p \colon t_0 \times t_1}

\bijudge{\(\times\)E}
        {\(\Gamma \vdash p_0 \colon t_0 \times t_1\)}
        {\(\Delta \vdash p_1 \colon t_1\)}
        {\(\Gamma, \, \Delta \vdash p_0 p_1 \colon t_1\)}

\axiom{\(\unit\)R}
      {\( \success \pass p \step p \)}

\axiom{\(\times\)R}
      {\( ( \forall (x \colon t ). p_0) \, p_1 \step [x_t \update p_1] p_0 \)}

\end{flushleft}


\subsubsection*{Value Calculus}

\begin{flushleft}

\judge{V}
      {x \colon t \in \Gamma}
      {\Gamma \vdash x \colon t}

\axiom{\(\unit\)I}
      {\(\Gamma \vdash \coin \colon \unit \)}

{\judge{\(\times\text{E}_1\)}
       {\Gamma \vdash v \colon t_0 \times t_1}
       {\Gamma \vdash \fst(v) \colon t_0}
\hfill
\judge{\(\times\text{E}_2\)}
      {\Gamma \vdash v \colon t_0 \times t_1}
      {\Gamma \vdash \snd(v) \colon t_1 }
}

\bijudge{\(\times\)I}
        {\(\Gamma \vdash v_0 \colon t_0\)}
        {\(\Gamma \vdash v_1 \colon t_1\)}
        {\(\Gamma \vdash (v_0, v_1) \colon t_0 \times t_1 \)}

{\axiom{\(\times\text{R}_1\)}
       {\(\fst (v_0 , v_1 ) \step v_0 \)}

\hfill
\axiom{\(\times\text{R}_2\)}
      {\(\snd (v_0 , v_1 ) \step v_1 \)}
}

\end{flushleft}

\subsubsection*{Satisfaction Judgements}

I need a better symbol here.

\begin{flushleft}

\judge{VAR-S}
      {v \models x_t \in \sigma}
      {v \models x_t \with [\sigma]}

\bijudge{vR-S}
        {\(v_0 \step v_1\)}
        {\(v_0 \models p \with [\sigma]\)}
        {\( v_1 \models p \with [\sigma] \)}

\bijudge{pR-S}
        {\(p_0 \step p_1\)}
        {\(v \models p_0 \with [\sigma]\)}
        {\(v \models p_1 \with [\sigma] \)}

\axiom{\(\unit\)S}
      {\(\coin \models \success \with [\sigma] \)}

\judge{\(\times\)S}
      {v_1 \models p \with [ \sigma , \, v_0 \models x_t]}
      {( v_0 , v_1 ) \models \forall (x \colon t ). p \with [\sigma]}

\end{flushleft}

\section*{Examples}

Pattern matching on equality

\begin{prooftree}

  \taut
  \RightLabel{\scriptsize{(VAR-S)}}
  \UnaryInfC{\( v \models x_t \with [ \sigma , \, v \models x_t] \)}
  \RightLabel{\scriptsize{(\(\times\)S)}}
  \UnaryInfC{\( ( v , v ) \models \forall (x \colon t). x_t \with [\sigma] \)}

\end{prooftree}

Transposition

\(  \forall (p \colon t \times t \times \unit) (x \colon t) (y \colon t). p_(t \times t \times \unit) \, y_t \, x_t \)

\section*{Disjoint Unions}

Disjoint unions in \Set become Cartesian product/coproduct in \Rel.
It might make sense to use different notations for coproduct in \Rel.

I decided against rules for mapping from \Set to \Rel because I wanted
to see how far \Rel could go on its own and also wanted to see if
these could be defined later.

I have a hunch it is proper for the combination of product/coproduct
to introduce nondeterminism in the operational semantics but I need to
think more about the issue.

As a technical hack \(\false\) is explicitly indexed by the environment it ignores.
This hack also requires inferring the environment in certain reduction rules.

\begin{description}[nosep]
\item[Types] \hfill \( t \bnfdef \ldots \mid \mt \mid t + t \)
\item[Values] \hfill \( v \bnfdef \ldots \mid \absurd_t(v) \mid \inl_t(v) \mid \inr_t(v) \mid
  \case(v, x. v, x. v)
  \)
\item[Predicates] \hfill \( p \bnfdef \ldots \mid
  \absurd_t(p) \mid \inl_t(p) \mid \inr_t(p) \mid \case(v, x. v, x. v) \mid
  \false_\Gamma \mid \lft(p) \mid \rgt(p) \mid [ p \mid p ] \)
\end{description}

\subsubsection*{Values}

\begin{flushleft}

\judge{\(\mt\)E}
        {\Gamma \vdash v \colon \mt}
        {\Gamma \vdash \absurd_t(v) \colon t}

{\judge{\(+\text{I}_1\)}
       {\Gamma \vdash v \colon t_0}
       {\Gamma \vdash \inl_{t_1}(v) \colon t_0 + t_1}
\hfill
\judge{\(+\text{I}_2\)}
      {\Gamma \vdash v \colon t_1}
      {\Gamma \vdash \inr_{t_0}(v) \colon t_0 + t_1}
}

\trijudge{\(+\)E}
         {\( \Gamma \vdash v_0 \colon t_0 + t_1 \)}
         {\( \Gamma , \, x_0 \colon t_0 \vdash v_1 \colon t_2 \)}
         {\( \Gamma , \, x_1 \colon t_1 \vdash v_1 \colon t_2 \)}
         {\(
  \Gamma \vdash
  \case(v_0, x_0. v_1, x_1. v_2)
  \colon t_2 
\)}

\axiom{\(+\text{R}_1\)}
      {\(
  \case(\inl_t(v_0), x_0. v_1, x_1. v_2) \step [x_0 \update v_0] v_1
  \)}

\axiom{\(+\text{R}_2\)}
      {\(
  \case(\inr_t(v_0), x_0. v_1, x_1. v_2) \step [x_1 \update v_0] v_2
  \)}

\end{flushleft}


\subsubsection*{Predicates}

\begin{flushleft}

\judge{\(\mt\text{E}^\text{T}\)}
      {\Gamma \vdash p \colon \mt}
      {\Gamma \vdash \absurd_t(v) \colon t}

{\judge{\(+\text{I}^\text{T}_1\)}
       {\Gamma \vdash p \colon t_0}
       {\Gamma \vdash \inl_{t_1}(v) \colon t_0 + t_1}
\hfill
\judge{\(+\text{I}^\text{T}_2\)}
      {\Gamma \vdash p \colon t_1}
      {\Gamma \vdash \inr_{t_0}(v) \colon t_0 + t_1}
}

\bijudge{\(+\text{E}^\text{T}\)}
        {\( \Gamma \vdash p_0 \colon t_0 + t_1 \)}
        {\( \Gamma , \, x_0 \colon t_0 \vdash p_1 \colon t_2 \)}
        {\( \Gamma , \, x_1 \colon t_1 \vdash p_1 \colon t_2 \)}
        {\(
  \Gamma \vdash
  \case(p_0, x_0. p_1, x_1. p_2)
  \colon t_2 
\)}

\axiom{\(\mt\)I}
      {\( \Gamma \vdash \false_\Gamma \colon \mt \)}

{\judge{\(+\text{E}_1\)}
       {\Gamma \vdash p \colon t_0 + t_1}
       {\Gamma \vdash \lft(p) \colon t_0}
\hfill
\judge{\(+\text{E}_2\)}
      {\Gamma \vdash p \colon t_0 + t_1}
      {\Gamma \vdash \rgt(p) \colon t_1)}
}

\bijudge{\(+\)I}
        {\( \Gamma \vdash p_0 \colon t_0 \)}
        {\( \Gamma \vdash p_1 \colon t_1 \)}
        {\( \Gamma \vdash [p_0 \mid p_1] \colon t_0 + t_1 \)}

\axiom{\(+\text{R}^\text{T}_1\)}
      {\(
  \case(\inl_t(p_0), x_0. p_1, x_1. p_2) \step [x_0 \update p_0] p_1
  \)}

\axiom{\(+\text{R}^\text{T}_2\)}
      {\(
  \case(\inr_t(p_0), x_0. p_1, x_1. p_2) \step [x_1 \update p_0] p_2
  \)}

{\axiom{\(+\text{R}_1\)}
  {\( \lft([ p_0 \mid p_1 ]) \step p_0 \)}
\axiom{\(+\text{R}_2\)}
      {\( \rgt([ p_0 \mid p_1 ]) \step p_1 \)}
}

{
\axiom{\(+\text{R}\text{R}^\text{T}_1\)}
      {\( \lft(\inl_t(p)) \step p \)}
\hfill
\axiom{\(+\text{R}\text{R}^\text{T}_2\)}
      {\( \rgt(\inr_t(p)) \step p \)}
}

{
\judge{\(+\text{R}\text{R}^\text{T}_3\)}
      {\Gamma \vdash p \colon t}
      {\lft(\inr_t(p)) \step \absurd_t(\false_\Gamma)}
\hfill
\judge{\(+\text{R}\text{R}^\text{T}_4\)}
      {\Gamma \vdash p \colon t}
      {\rgt(\inl_t(p)) \step \absurd_t(\false_\Gamma)}
}


\axiom{\(+\text{R}^\text{T}\text{R}_1\)}
      {\(
  \case([p_0 \mid p_1 ], x_0. p_2, x_1. p_3) \step [x_0 := p_0] p_2
  \)}

\axiom{\(+\text{R}^\text{T}\text{R}_2\)}
      {\(
  \case([p_0 \mid p_1 ], x_0. p_2, x_1. p_3) \step [x_1 := p_1] p_3
  \)}

\end{flushleft}


\subsubsection*{Satisfies}

\begin{flushleft}

{
\judge{\(+\text{S}_1\)}
      {v \models p_0 \with [\sigma]}
      {\inl_t(v) \models [ p_0 \mid p_1 ] \with [\sigma]}
\hfill
\judge{\(+\text{S}_2\)}
      {v \models p_1 \with [\sigma]}
      {\inr_t(v) \models [ p_0 \mid p_1 ] \with [\sigma]}
}

\judge{\(\mt\)S}
      {\absurd_t(v) \models p \with [\sigma]}
      {v \models \false \with [\sigma]}

\end{flushleft}

\section*{Dependent Sums}

If product of sets becomes an internal hom in the predicate calculus
then dependent sums ought to become a little like \(\Pi\) types.  So
the predicate calculus effectively becomes like a linear System-F.

Some things become awkward to interpret here though.

I also really can't figure out unpacking. It's messy if you don't want
full dependent types.

\begin{description}[nosep]
\item[Types] \hfill  \( t \bnfdef \ldots \mid x \mid \prop \mid \head(v) \mid \Sigma (x \colon \prop). t \)
\item[Values] \hfill  \( v \bnfdef \ldots \mid \tail(v) \mid \langle x \update t , v \rangle \)
\item[Predicates] \hfill  \( p \bnfdef \ldots \mid p \, t \mid \Forall (x \colon \prop). p \)
\item[Substitutions] \hfill  \( \sigma \bnfdef \ldots \mid \sigma , \, t \models x \)
\end{description}

Not really good at the typing judgements for dependent sum types.


\subsubsection*{Values}

\begin{flushleft}
  
\judge{\(\Sigma\text{E}_1\)}
      {\Gamma \vdash v \colon \Sigma (x \colon \prop). t}
      {\Gamma \vdash \head(v) \colon \prop}

\judge{\(\Sigma\text{E}_2\)}
      {\Gamma \vdash v \colon \Sigma (x \colon \prop). t}
      {\Gamma \vdash \tail(v) \colon [x \update \head(v)] t}


\bijudge{\(\Sigma\)I}
        {\( \Gamma \vdash t_0 \colon \prop  \)}
        {\( \Gamma , \, x \colon \prop \vdash v \colon t_1 \)}
        {\(
  \Gamma \vdash \langle x \update t_0 , v \rangle \colon \Sigma (x \colon \prop). t_0  \)}


{\axiom{\(\Sigma\text{S}_1\)}
  {\( \head(\langle x \update t , v \rangle) \step t \)}
\hfill
\axiom{\(\Sigma\text{S}_2\)}
      {\( \tail( \langle x \update t , v \rangle) \step [x \update t] v \)}
}
\end{flushleft}

\subsubsection*{Predicates}

\begin{flushleft}

\bijudge{\(\Sigma\)E}
        {\( \Gamma \vdash p \colon \Sigma (x\colon \prop). t_1  \)}
        {\( \Delta \vdash t_0 \colon \prop \)}
        {\( \Gamma, \, \Delta \vdash p_0 \, t_0 \colon [x \update t_0] t_1 \)}

\judge{\(\Sigma\)I}
      {\Gamma , \, x \colon \prop \vdash p \colon t}
      {\Gamma \vdash \Forall (x \colon \prop). p \colon \Sigma (x \colon \prop). t}

\axiom{\(\Sigma\)R}
      {\( ( \Forall (x \colon \prop). p) \, t \step [x \update t] p \)}

\end{flushleft}

\subsubsection*{Satisfaction}
I can't figure out satisfaction at all.

\begin{flushleft}
\judge{\(\Sigma\)S}
      {v \models p \with [ \sigma , \, t \models x]}
      {
  \langle x \update t , v \rangle \models \Forall (x \colon \prop). p \with [\sigma]
  }
\end{flushleft}

\section*{Categorical Semantics}
%% Useful as hell, cite somewhere ?
%% https://tikzcd.yichuanshen.de/

The intent is to create calculi encoding the core features of the
double category \Rel.

If this is successful then terms and types ought to map to \Rel as
follows.

\begin{center}
  \begin{tikzcd}
    \unit \arrow{dd}[']{\sigma_p} \arrow{rr}{\sigma_v} & {} \arrow[Rightarrow]{dd}{v \models p \, [\sigma_v , \sigma_p]} & \times_{x\colon t \in \Gamma_v} t \arrow{dd}{v} \\
    &                               &                      \\
    \times_{x\colon t \in \Gamma_p} t \arrow{rr}[']{p}                           & {}                            & t                   
  \end{tikzcd}
\end{center}

I have no idea about universe issues and such. Dependent sum is probably wrong.

Really need to think about denotation again.

\begin{multline*}
  \\
  \llbracket \unit \rrbracket = \{ \emptyset \} \\
  \llbracket t_0 \times t_1 \rrbracket = \llbracket t_0 \rrbracket \times \llbracket t_1 \rrbracket \\
  \llbracket \mt \rrbracket = \emptyset \\
  \llbracket t_0 + t_1 \rrbracket = \llbracket t_0 \rrbracket \sqcup \llbracket t_1 \rrbracket \\
  \llbracket \Sigma (x \colon \prop). t(x) \rrbracket = \bigsqcup_{ x \in \prop} \llbracket t(x) \rrbracket \\
  \\
  \llbracket \coin \rrbracket = \emptyset \\
  \llbracket ( v_0 , v_1 ) \rrbracket = ( \llbracket v_0 \rrbracket , \llbracket v_1 \rrbracket ) \\
  \\
  \llbracket \success \rrbracket(y) = \top \\
  \llbracket p_0 p_1 \rrbracket(y) = \exists z,  \llbracket p_1 \rrbracket (z) \wedge \llbracket p_0 \rrbracket (z, y)\\
  \llbracket \forall (x \colon t). p \rrbracket(\langle x, y \rangle) = \llbracket p(x) \rrbracket (y)  \\
\end{multline*}

%% \item[Values] \hfill \( v \bnfdef x \mid \coin \mid \fst(v) \mid \snd(v) \mid ( v , v ) \)
%% \item[Predicates] \hfill \( p \bnfdef x \mid \success \mid p \pass p \mid p \, p \mid \forall (x \colon t) . p \)

\section*{The Future?}

Satisifies judgments correspond to thin squares. Moving to more
general categories such as \textbf{Span} or \textbf{Prof} or
\textbf{Vect} for matrix math requires an interpretation of squares
carrying constructive content.

\end{document}
