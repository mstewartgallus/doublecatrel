embed
{{ coq
Require Blech.Map.
}}

metavar var, x, y ::= {{ coq nat }} {{ coq-equality }} {{ lex alphanum}} {{ tex \mathit{[[var]]} }}

grammar
type, t :: 't_' ::=
  | unit         ::   :: unit
  | t * t'       ::   :: prod

term, v :: 'v_' ::=
  | tt           ::   :: tt
  | fst v        ::   :: fst
  | snd v        ::   :: snd
  | v , v'       ::   :: fanout
  | ( v )        :: S :: paren {{ icho ([[v]]) }}

context, E :: 'E_' ::=
  | x                        ::   :: var
  | lam x : t . E            ::   :: lam (+ bind x in E +)
  | E E'                     ::   :: app
  | tt                       ::   :: tt
  | E ; E'                  ::   :: step
  | E , E'                   ::   :: fanout
  | let ( x , y ) := E in E' ::   :: let (+ bind x union y in E' +)
  | ( E )                    :: S :: paren {{ icho ([[E]]) }}

command, c :: 'c_' ::=
  | x [ N ]               ::   :: var
  | lam x : t . c         ::   :: lam (+ bind x in c +)
  | c c'                  ::   :: app
  | tt                    ::   :: tt
  | c ; c'                ::   :: step
  | c , c'                ::   :: fanout
  | let ( x , y ) := c in c' ::   :: let (+ bind x union y in c' +)
  | ( c )                    :: S :: paren {{ icho ([[c]]) }}


environment, G {{ tex \Gamma }} :: 'G_' ::= {{ coq (Map.map type) }} {{ coq-universe Type }}
  | empty         ::   :: empty {{ coq Map.empty }}
  | G , x : t     ::   :: add {{ coq (Map.add [[x]] [[t]] [[G]]) }}
  | G ++ G'       ::   :: merge {{ coq (Map.merge [[G]] [[G']]) }}

store, D {{ tex \sigma }} :: 'D_'  ::= {{ coq (Map.map normal) }} {{ coq-universe Type }}
  | empty                 ::   :: empty {{ coq Map.empty }}
  | D , x [ N ]            ::   :: add {{ coq (Map.add [[x]] [[N]] [[D]]) }}
  | D ++ D'               ::   :: merge {{ coq (Map.merge [[D]] [[D']]) }}

normal, N :: 'N_' ::=
  | tt      ::  :: tt
  | N , N'  ::  :: fanout
  | ( N )   :: S :: paren {{ coq ([[N]]) }}

terminals :: 'terminals_' ::=
  | :            ::   :: in     {{ tex \colon{} }}
  | |-           ::   :: turnstile   {{ tex \vdash{} }}
  | :=           ::   :: update  {{ tex \mathbin{:=} }}
  | ++           ::   :: merge   {{ tex \cup{} }}
  | unit         ::   :: unit  {{ tex \top{} }}
  | *            ::   :: prod  {{ tex \times{} }}
  | ;           ::   :: then  {{ tex ; }}
  | tt           ::   :: tt   {{ tex \mathop{ \textbf ! } }}
  | fst          ::   :: fst  {{ tex \pi{}_1 }}
  | snd          ::   :: snd  {{ tex \pi{}_2 }}
  | lam          ::   :: lam  {{ tex \lambda{} }}
  | empty        ::   :: empty   {{ tex \bullet{} }}
  | !            ::   :: big     {{ tex \mathrel{\Downarrow} }}

embed
{{ coq

Module Examples.

Example id [[t]] :=
 let [[x]] := 0 in
[[ lam x: t. x ]]. 

End Examples.
}}

defns

judge_context :: 'J' ::= {{ coq-universe Type }}

defn
G |- E : t ::   :: E :: 'E_'
by

------------ :: var
empty , x: t |- x: t

G , x: t1 |- E: t2
-------------------------- :: abs
G |- lam x: t1 . E: t1 * t2

G1 |- E1: t1 * t2
G2 |- E2: t1
------------------ :: app
G1 ++ G2 |- E1 E2: t2

------------------- :: tt
empty |- tt: unit

G1 |- E1: unit
G2 |- E2: t
------------------- :: step
G1 ++ G2 |- E1; E2: t

G1 |- E1: t1
G2 |- E2: t2
------------------- :: fanout
G1 ++ G2 |- E1, E2: t1 * t2

G1 |- E1 : t1 * t2
G2, x0: t1, x1: t2 |- E2: t3
------------------- :: let
G1 ++ G2 |- let (x0, x1) := E1 in E2: t3

defns

judge_term :: 'J' ::= {{ coq-universe Type }}

defn
|- v : t ::   :: v :: 'v_'
by

------------ :: tt
|- tt: unit

|- v1: t1
|- v2: t2
------------------ :: fanout
|- v1, v2: t1 * t2

|- v: t1 * t2
------------------ :: fst
|- fst v: t1

|- v: t1 * t2
------------------ :: snd
|- snd v: t2

defns

big :: '' ::= {{ coq-universe Type }}

defn
v ! N ::   :: big :: 'big_'
by

-------------------- :: tt
tt ! tt

v1 ! N1'
v2 ! N2'
-------------------- :: fanout
(v1, v2) ! (N1', N2')

v ! N1, N2
-------------------- :: fst
fst v ! N1

v ! N1, N2
------------------- :: snd
snd v ! N2

defns

sat :: '' ::=

defn
D |- c : E [ N ] ::   :: sat :: 'sat_'
by

----------------------------- :: var
empty, x[N] |- x[N]: x[N]

--------------------- :: tt
empty |- tt: tt[tt]

D |- c: E[tt]
D' |- c': E'[N]
------------------------------- :: step
D ++ D' |- c; c': (E; E')[N]

D |- c: E[N]
D' |- c': E'[N']
--------------------------------- :: fanout
D ++ D' |- c, c': (E, E')[N, N']

D |- c: E[N0, N1]
D', x[N0], y[N1] |- c': E'[N2]
------------------------------- :: let
D ++ D' |- let (x, y) := c in c': (let (x, y) := E in E')[N2]

D, x[N] |- c: E[N']
------------------------------- :: lam
D |- (lam x: t. c) : (lam x: t. E)[N, N']

D |- c: E[N, N']
D' |- c': E'[N ]
---------------------------- :: app
D ++ D' |- c c': E E'[N']

defns

pick :: '' ::=

defn
D |- E ! c ::   :: pick :: 'p_'
by

----------------------------- :: var
empty, x[N] |- x ! x[N]

--------------------- :: tt
empty |- tt ! tt

D |- E ! tt
D' |- E' ! c
------------------------------- :: step
D ++ D' |- E; E' ! c

D |- E ! c
D' |- E' ! c'
--------------------------------- :: fanout
D ++ D' |- E, E' ! c, c'

D |- E ! c
D |- c: E [N, N']
D', x[N], y[N'] |-  E' ! c'
--------------------------------------------------------- :: let
D ++ D' |- let (x, y) := E in E' ! let (x, y) := c in c'

% nondeterministically pick a value N
D, x[N] |- E ! c
----------------------------------- :: lam
D |- (lam x: t. E) ! (lam x: t. c)

D |- E ! c
D' |- E' ! c'
---------------------------- :: app
D ++ D' |- E E' ! c c'
