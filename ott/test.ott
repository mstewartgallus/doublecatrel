embed
{{ coq
Require Blech.Map.

Require Import FunInd.
}}

metavar var, x ::= {{ coq nat }} {{ coq-equality }} {{ lex alphanum}} {{ tex \mathit{[[var]]} }}
indexvar index, i, n ::= {{ isa num }} {{ coq nat }}

grammar
type, t :: 't_' ::=
  | unit         ::   :: unit
  | t * t'       ::   :: prod

term, v :: 'v_' ::=
  | tt           ::   :: tt
  | fst v        ::   :: fst
  | snd v        ::   :: snd
  | v , v'       ::   :: fanout
  | V . v        :: M :: ctx {{ icho (appctx_term_ctx_term [[V]] [[v]]) }}
  | ( v )        :: S :: paren {{ coq ([[v]]) }}

context, E :: 'E_' ::=
  | x                 ::   :: var
  | forall x : t . E  ::   :: all (+ bind x in E +)
  | E E'              ::   :: app
  | [ x := E ] E'     :: M :: subst
                             {{ icho (subst_context [[E]] [[x]] [[E']]) }}
  | e . E             :: M :: ctx {{ icho (appctx_context_ctx_context [[e]] [[E]]) }}
  | ( E )             :: S :: paren {{ icho ([[E]]) }}

environment, G {{ tex \Gamma }} :: 'G_' ::= {{ coq Map.map type }} {{ coq-universe Type }}
  | x : t         :: M :: ofty {{ icho (Map.one [[x]] [[t]]) }}
  | G , x : t     :: M :: add {{ icho (Map.add [[x]] [[t]] [[G]]) }}
  | G ++ G'        :: M :: merge {{ icho (Map.merge [[G]] [[G']]) }}
  | G \ x         :: M :: minus {{ icho (Map.minus [[x]] [[G]]) }}


term_ctx, V :: 'V_' ::=
  | fst __       ::  :: fst
  | snd __       ::  :: snd
  | v , __  ::  :: fanout_l
  | __ , v  ::  :: fanout_r

term_norm, N :: 'N_' ::=
  | tt      ::  :: tt
  | N , N'  ::  :: fanout

% FIXME give better name, symbols
context_ctx, e :: 'e_' ::=
  | forall x : t . __   ::  :: forall
  | E __                ::  :: app_l
  | __ E                 ::  :: app_r

context_whnf, J :: 'J_' ::=
  | forall x : t . E  ::   :: all (+ bind x in E +)

terminals :: 'terminals_' ::=
  | \            ::   :: minus   {{ tex \setminus }}
  | :            ::   :: in     {{ tex \colon }}
  | |-           ::   :: turnstile   {{ tex \vdash }}
  | :=           ::   :: update  {{ tex \mathbin{:=} }}
  | ++           ::   :: app    {{ tex , }}
  | unit         ::   :: unit  {{ tex \top }}
  | *            ::   :: prod  {{ tex \times }}
  | tt           ::   :: tt   {{ tex ! }}
  | fst          ::   :: fst  {{ tex \pi_1 }}
  | snd          ::   :: snd  {{ tex \pi_2 }}
  | __           ::   :: hole    {{ tex [\cdot] }}
  | forall       ::   :: forall  {{ tex \forall }}
  | empty        ::   :: empty   {{ tex \bullet }}
  | @            ::   :: sat     {{ tex \otimes }}
  | -->          ::   :: step     {{ tex \longrightarrow }}
  | *->          ::   :: multi     {{ tex \Rightarrow }}

substitutions
  single context var :: subst 

contextrules
  V _:: v :: v
  e _:: E :: E

subrules
  N <:: v
  J <:: E

freevars
  context var :: fv

defns

judge :: '' ::=

defn
G |- E : t ::   :: judge_E :: 'JE_'
by

------------ :: var
x : t |- x : t

G , x : t1 |- E : t2
-------------------------- :: abs
G |- forall x : t1 . E : t1 * t2

G1 |- E1 : t1 * t2
G2 |- E2 : t1
------------------ :: app
G1 ++ G2 |- E1 E2 : t2

defn
|- v : t ::   :: judge_v :: 'Jv_'
by

------------ :: tt
|- tt : unit

|- v1 : t1
|- v2 : t2
------------------ :: fanout
|- v1 , v2 : t1 * t2

|- v : t1 * t2
------------------ :: fst
|- fst v : t1

|- v : t1 * t2
------------------ :: snd
|- snd v : t2


defn
|- E @ v ::   :: sat :: 'sat_'
by

------------------ :: tt
|- E @ tt

|- E0 @ v
|- E1 @ fst v
------------------ :: app
|- E0 E1 @ snd v

defns

eval :: '' ::=

defn
E --> E' ::   :: step_E :: 'stepE_'
by

------------------------------- :: beta
(forall x : t . E) E' --> [x := E'] E

E --> E'
----------------- :: ctx
e . E  --> e . E'

defn
v --> v' ::   :: step_v :: 'stepv_'
by

-------------------- :: beta1
fst (v1, v2) --> v1

------------------- :: beta2
snd (v1, v2) --> v2

v --> v'
-------------------- :: ctx
V . v --> V . v'

defn
v *-> v' ::   :: multi_v :: 'multiv_'
by

-------------------- :: id
v *-> v

v1 --> v2
v2 *-> v3
-------------------- :: then
v1 *-> v3

defn
E *-> E' ::   :: multi_E :: 'multiE_'
by

-------------------- :: id
E *-> E

E1 --> E2
E2 *-> E3
-------------------- :: then
E1 *-> E3
