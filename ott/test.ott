embed
{{ coq
Require Blech.Map.
}}

metavar var, x, y ::= {{ coq nat }} {{ coq-equality }} {{ lex alphanum}} {{ tex \mathit{[[var]]} }}
indexvar index, i, j, m, n ::= {{ coq nat }}

grammar
type, t :: 't_' ::=
  | unit         ::   :: unit
  | t * t'       ::   :: prod

term, v :: 'v_' ::=
  | x            ::   :: var
  | tt           ::   :: tt
  | fst v        ::   :: fst
  | snd v        ::   :: snd
  | v , v'       ::   :: fanout
  | ( v )        :: S :: paren {{ icho ([[v]]) }}

context, E :: 'E_' ::=
  | x                        ::   :: var
  | lam x : t . E            ::   :: lam (+ bind x in E +)
  | E E'                     ::   :: app
  | tt                       ::   :: tt
  | E ; E'                  ::   :: step
  | E , E'                   ::   :: fanout
  | let ( x , y ) := E in E' ::   :: let (+ bind x union y in E' +)
  | ( E )                    :: S :: paren {{ icho ([[E]]) }}

environment, G {{ tex \Gamma }} :: 'G_' ::= {{ coq (Map.map type) }} {{ coq-universe Type }}
  | nil         ::   :: nil {{ coq Map.empty }}
  | G , x : t     ::   :: add {{ coq (Map.add [[x]] [[t]] [[G]]) }}
  | G ++ G'       ::   :: merge {{ coq (Map.merge [[G]] [[G']]) }}

store, D {{ tex \sigma }} :: 'D_'  ::= {{ coq (Map.map normal) }} {{ coq-universe Type }}
  | nil                   ::   :: nil {{ coq Map.empty }}
  | D , x [ N ]           ::   :: add {{ coq (Map.add [[x]] [[N]] [[D]]) }}
  | D ++ D'               ::   :: merge {{ coq (Map.merge [[D]] [[D']]) }}

span, P :: 'P_' ::= {{ coq-universe Type }}
  | D |- N  ::   :: with

set, X :: 'X_' ::= {{ coq (list span) }} {{ coq-universe Type }}
  | nil          ::   :: nil {{ coq nil }}
  | X , P         ::   :: cons {{ coq (cons [[P]] [[X]]) }}

normal, N :: 'N_' ::=
  | tt      ::  :: tt
  | N , N'  ::  :: fanout
  | ( N )   :: S :: paren {{ coq ([[N]]) }}

terminals :: 'terminals_' ::=
  | :            ::   :: in     {{ tex \colon{} }}
  | |-           ::   :: turnstile   {{ tex \vdash{} }}
  | :=           ::   :: update  {{ tex \mathbin{:=} }}
  | ++           ::   :: merge   {{ tex \cup{} }}
  | unit         ::   :: unit  {{ tex \top{} }}
  | *            ::   :: prod  {{ tex \times{} }}
  | tt           ::   :: tt   {{ tex \mathop{ \textbf ! } }}
  | fst          ::   :: fst  {{ tex \pi{}_1 }}
  | snd          ::   :: snd  {{ tex \pi{}_2 }}
  | lam          ::   :: lam  {{ tex \lambda{} }}
  | nil          ::   :: nil   {{ tex \bullet{} }}
  | !            ::   :: big     {{ tex \mathrel{\Downarrow} }}

substitutions
  single v x :: subst
  single E x :: subst 

embed
{{ coq

Module Examples.

Example id [[t]] :=
 let [[x]] := 0 in
[[ lam x: t. x ]]. 

End Examples.
}}

defns

judge_context :: 'J' ::= {{ coq-universe Type }}

defn
G |- E : t ::   :: E :: 'E_'
by

------------ :: var
nil , x: t |- x: t

G , x: t1 |- E: t2
-------------------------- :: abs
G |- lam x: t1 . E: t1 * t2

G1 |- E1: t1 * t2
G2 |- E2: t1
------------------ :: app
G1 ++ G2 |- E1 E2: t2

------------------- :: tt
nil |- tt: unit

G1 |- E1: unit
G2 |- E2: t
------------------- :: step
G1 ++ G2 |- E1; E2: t

G1 |- E1: t1
G2 |- E2: t2
------------------- :: fanout
G1 ++ G2 |- E1, E2: t1 * t2

G1 |- E1 : t1 * t2
G2, x0: t1, x1: t2 |- E2: t3
------------------- :: let
G1 ++ G2 |- let (x0, x1) := E1 in E2: t3

defns

judge_term :: 'J' ::= {{ coq-universe Type }}

defn
G |- v : t ::   :: v :: 'v_'
by

{{ Map.find [[x]] [[G]] = Some [[t]] }}
------------ :: var
G |- x: t

------------ :: tt
G |- tt: unit

G |- v1: t1
G |- v2: t2
------------------ :: fanout
G |- v1, v2: t1 * t2

G |- v: t1 * t2
------------------ :: fst
G |- fst v: t1

G |- v: t1 * t2
------------------ :: snd
G |- snd v: t2

defns

big :: '' ::= {{ coq-universe Type }}

defn
v ! N ::   :: big :: 'big_'
by

-------------------- :: tt
tt ! tt

v1 ! N1'
v2 ! N2'
-------------------- :: fanout
(v1, v2) ! (N1', N2')

v ! N1, N2
-------------------- :: fst
fst v ! N1

v ! N1, N2
------------------- :: snd
snd v ! N2

defns

sat :: '' ::=

defn
E ! P ::   :: sat :: 'sat_'
by

---------------------- :: var
x ! nil, x[N] |- N

------------------ :: tt
tt ! nil |- tt

E !  D |- tt 
E' !  D' |- N 
-------------------------- :: step
(E; E') !  D ++ D' |- N 

E !  D |- N 
E' !  D' |- N' 
-------------------------- :: fanout
(E, E') !  D ++ D' |- N, N'

E !  D |- N0, N1 
E' !  D', x[N0], y[N1] |- N2 
------------------------------------------- :: let
(let (x, y) := E in E') !  D ++ D' |- N2 

E !  D, x[N] |- N' 
------------------------------- :: lam
(lam x: t. E) !  D |- N, N' 

E !  D |- N, N' 
E' !  D' |- N 
------------------------- :: app
E E' !  D ++ D' |- N' 

defns

sound :: '' ::=

defn
E ! X ::   :: sound :: 'sound_'
by

------- :: nil
E ! nil

E ! X
E ! P
-------- :: cons
E ! X, P
