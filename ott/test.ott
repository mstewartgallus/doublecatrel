embed
{{ coq
Require Blech.Map.
}}

metavar var, x ::= {{ coq nat }} {{ coq-equality }} {{ lex alphanum}} {{ tex \mathit{[[var]]} }}
indexvar index, i, n ::= {{ isa num }} {{ coq nat }}

grammar
type, t :: 't_' ::=
  | unit         ::   :: unit
  | t * t'       ::   :: prod

term, v :: 'v_' ::=
  | tt           ::   :: tt
  | fst v        ::   :: fst
  | snd v        ::   :: snd
  | v , v'       ::   :: fanout
  | ( v )        :: S :: paren {{ coq ([[v]]) }}

context, E :: 'E_' ::=
  | x                 ::   :: var
  | forall x : t . E  ::   :: all (+ bind x in E +)
  | E E'              ::   :: app
  | [ x := E ] E'     :: M :: subst
                             {{ icho (subst_context [[E]] [[x]] [[E']]) }}
  | ( E )             :: S :: paren {{ icho ([[E]]) }}

environment, G {{ tex \Gamma }} :: 'G_' ::= {{ coq Map.map type }} {{ coq-universe Type }}
  | x : t         :: M :: ofty {{ icho (Map.one [[x]] [[t]]) }}
  | G , G'        :: M :: merge {{ icho (Map.merge [[G]] [[G']]) }}
  | G \ x         :: M :: minus {{ icho (Map.minus [[x]] [[G]]) }}

terminals :: 'terminals_' ::=
  | \            ::   :: minus   {{ tex \setminus }}
  | :            ::   :: in     {{ tex \colon }}
  | |-           ::   :: turnstile   {{ tex \vdash }}
  | :=           ::   :: update  {{ tex \mathbin{:=} }}
  | ++           ::   :: app    {{ tex , }}
  | unit         ::   :: unit  {{ tex \top }}
  | *            ::   :: prod  {{ tex \times }}
  | fst          ::   :: fst  {{ tex \pi_1 }}
  | snd          ::   :: snd  {{ tex \pi_2 }}
  | forall       ::   :: forall  {{ tex \forall }}
  | empty        ::   :: empty   {{ tex \bullet }}
  | @            ::   :: sat     {{ tex \otimes }}
  | -->          ::   :: red     {{ tex \longrightarrow }}

substitutions
  single context var :: subst 

freevars
  context var :: fv

defns

judge :: '' ::=

defn
G |- E : t ::   :: judge_E :: 'JE_'
by

------------ :: var
x : t |- x : t

% FIXME
{{ Map.find [[x]] [[G]] = Some [[t1]] }}
G |- E : t2
-------------------------- :: abs
G \ x |- forall x : t1 . E : t1 * t2

G1 |- E1 : t1 * t2
G2 |- E2 : t1
------------------ :: app
G1 , G2 |- E1 E2 : t2

defn
|- v : t ::   :: judge_v :: 'Jv_'
by

------------ :: tt
|- tt : unit

|- v1 : t1
|- v2 : t2
------------------ :: fanout
|- v1 , v2 : t1 * t2

|- v : t1 * t2
------------------ :: fst
|- fst v : t1

|- v : t1 * t2
------------------ :: snd
|- snd v : t2


defn
|- E @ v ::   :: sat :: 'sat_'
by

------------------ :: tt
|- E @ tt

|- E0 @ v
|- E1 @ fst v
------------------ :: app
|- E0 E1 @ snd v

defns

eval :: '' ::=

defn
E --> E' ::   :: step_E :: 'stepE_'
by

------------------------------- :: beta
(forall x : t . E1) E2 --> [x := E2] E1

E1 --> E1'
----------------- :: app
E1 E2 --> E1' E2

defn
v --> v' ::   :: step_v :: 'stepv_'
by

v1 --> v1'
-------------------- :: fanout1
v1, v2 --> v1', v2

v2 --> v2'
-------------------- :: fanout2
v1, v2 --> v1, v2'

-------------------- :: beta1
fst (v1, v2) --> v1

------------------- :: beta2
snd (v1, v2) --> v2