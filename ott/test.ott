embed
{{ coq
Require Blech.Map.
}}

metavar vvar, x, y ::= {{ coq nat }} {{ coq-equality }} {{ lex alphanum}} {{ tex \mathit{[[vvar]]} }}
metavar cvar, X, Y ::= {{ coq nat }} {{ coq-equality }} {{ lex alphanum}} {{ tex \mathit{[[cvar]]} }}

grammar
type, t :: 't_' ::= {{ coq-equality }}
  | unit         ::   :: unit
  | t * t'       ::   :: prod

context, E :: 'E_' ::=
  | X                        ::   :: var
  | lam X : t . E            ::   :: lam (+ bind X in E +)
  | E E'                     ::   :: app
  | tt                       ::   :: tt
  | E ; E'                   ::   :: step
  | E , E'                   ::   :: fanout
  | let ( X , Y ) := E in E' ::   :: let (+ bind X union Y in E' +)
  | ( E )                    :: S :: paren {{ icho ([[E]]) }}

term, v :: 'v_' ::=
  | x              ::   :: var
  | tt             ::   :: tt
  | fst v          ::   :: fst
  | snd v          ::   :: snd
  | v , v'         ::   :: fanout
  | ( v )          :: S :: paren {{ icho ([[v]]) }}
  | [ x := v ] v'  :: S :: subst {{ icho (subst_term [[v]] [[x]] [[v']]) }}

normal, N :: 'N_' ::= {{ coq-equality }}
  | tt      ::   :: tt
  | N , N'  ::   :: fanout
  | ( N )   :: S :: paren {{ coq ([[N]]) }}

linear, D {{ tex \Delta }} :: 'D_' ::= {{ coq (Map.map type) }} {{ coq-universe Type }}
  | nil           :: M :: nil {{ coq Map.empty }}
  | D , X : t     :: M :: add {{ coq (Map.add [[X]] [[t]] [[D]]) }}
  | D ++ D'       :: M :: merge {{ coq (Map.merge [[D]] [[D']]) }}

environment, G {{ tex \Gamma }} :: 'G_' ::= {{ coq (list (vvar * type)) }}
  | nil         ::   :: nil {{ coq nil }}
  | G , x : t     ::   :: add {{ coq (cons ([[x]], [[t]]) [[G]]) }}

store, S {{ tex \sigma }} :: 'S_'  ::= {{ coq (Map.map normal) }} {{ coq-universe Type }}
  | nil                   :: M :: nil {{ coq Map.empty }}
  | S , X := N            :: M :: add {{ coq (Map.add [[X]] [[N]] [[S]]) }}
  | S ++ S'               :: M :: merge {{ coq (Map.merge [[S]] [[S']]) }}

span, P :: 'P_' ::= {{ coq-universe Type }}
  | S |- N  ::   :: with

set, Ps {{ tex P^* }} :: 'X_' ::= {{ coq (list span) }} {{ coq-universe Type }}
  | nil          ::   :: nil {{ coq nil }}
  | Ps , P       ::   :: cons {{ coq (cons [[P]] [[Ps]]) }}

subst, p {{ tex \rho }} :: 'p_'  ::= {{ coq (list (vvar * normal)) }}
  | nil                   :: M :: nil {{ coq nil }}
  | p , x := N            :: M :: add {{ coq (cons ([[x]], [[N]]) [[p]]) }}
  | ( p )                 :: S :: paren {{ coq ([[p]]) }}

terminals :: 'terminals_' ::=
  | :            ::   :: in     {{ tex \colon{} }}
  | |-           ::   :: turnstile   {{ tex \vdash{} }}
  | :=           ::   :: update  {{ tex \mathbin{:=} }}
  | ++           ::   :: merge   {{ tex \cup{} }}
  | unit         ::   :: unit  {{ tex \textbf{I} }}
  | *            ::   :: prod  {{ tex \otimes{} }}
  | tt           ::   :: tt   {{ tex \mathop{ \textbf ! } }}
  | fst          ::   :: fst  {{ tex \pi{}_1 }}
  | snd          ::   :: snd  {{ tex \pi{}_2 }}
  | lam          ::   :: lam  {{ tex \lambda{} }}
  | nil          ::   :: nil   {{ tex \bullet{} }}
  | !            ::   :: big     {{ tex \mathrel{\Downarrow} }}
  | ==           ::   :: equiv   {{ tex \mathrel{\sim} }}

substitutions
  single v x :: subst

% subrules are awkward
funs
  toterm ::=
fun
  [ N ] :: v :: toterm {{ tex \llbracket [[N]] \rrbracket }}
by
  [ tt ] === tt
  [ N, N' ] === [ N ], [ N' ]

funs
  msubst ::=
fun
  [ p ] v' :: v :: msubst
by
  [ nil ] v' === v'
  [p, x := N] v' === [p] ([ x := [N] ] v')

embed
{{ coq

Coercion toterm: normal >-> term.

Definition find (x: vvar) (Î“: list (vvar * type)): option type :=
  match List.find (fun '(k, _) => if eq_vvar x k then true else false) Î“ with
  | Some (_, t) => Some t
  | _ => None
  end.
}}
defns

judge_context :: 'J' ::=

defn
D |- E : t ::   :: E :: 'E_'
by

------------ :: var
nil, X: t |- X: t

D, X: t1 |- E: t2
-------------------------- :: abs
D |- lam X: t1 . E: t1 * t2

D1 |- E1: t1 * t2
D2 |- E2: t1
------------------ :: app
D1 ++ D2 |- E1 E2: t2

------------------- :: tt
nil |- tt: unit

D1 |- E1: unit
D2 |- E2: t
------------------- :: step
D1 ++ D2 |- E1; E2: t

D1 |- E1: t1
D2 |- E2: t2
------------------- :: fanout
D1 ++ D2 |- E1, E2: t1 * t2

D1 |- E1 : t1 * t2
D2, X: t1, Y: t2 |- E2: t3
------------------- :: let
D1 ++ D2 |- let (X, Y) := E1 in E2: t3

defns

judge_term :: 'J' ::=

defn
G |- v : t ::   :: v :: 'v_'
by

{{ find [[x]] [[G]] = Some [[t]] }}
------------ :: var
G |- x: t

------------ :: tt
G |- tt: unit

G |- v1: t1
G |- v2: t2
------------------ :: fanout
G |- v1, v2: t1 * t2

G |- v: t1 * t2
------------------ :: fst
G |- fst v: t1

G |- v: t1 * t2
------------------ :: snd
G |- snd v: t2

defns

big :: '' ::=

defn
v ! N ::   :: big :: 'big_'
by

-------------------- :: tt
tt ! tt

v1 ! N1'
v2 ! N2'
-------------------- :: fanout
(v1, v2) ! (N1', N2')

v ! N1, N2
-------------------- :: fst
fst v ! N1

v ! N1, N2
------------------- :: snd
snd v ! N2

defns

sat :: '' ::=

defn
E ! S |- N ::   :: sat :: 'sat_'
by

---------------------- :: var
X ! nil , X := N |- N

------------------ :: tt
tt ! nil |- tt

E ! S |- tt 
E' ! S' |- N 
-------------------------- :: step
(E; E') !  S ++ S' |- N 

E !  S |- N 
E' !  S' |- N' 
-------------------------- :: fanout
(E, E') !  S ++ S' |- N, N'

E ! S |- N0, N1 
E' ! S', X := N0, Y := N1 |- N2 
------------------------------------------- :: let
(let (X, Y) := E in E') ! S ++ S' |- N2 

E ! S, X := N |- N' 
------------------------------- :: lam
(lam X: t. E) ! S |- N, N' 

E ! S |- N, N' 
E' ! S' |- N 
------------------------- :: app
E E' ! S ++ S' |- N' 

defns

judge :: 'J' ::=

defn
p : G ::   :: p :: 'p_'
by

---------- :: nil
nil: nil

nil |- [N] : t
p: G
------------------ :: cons
p, x := N: G, x: t

defns

sound :: '' ::=

defn
E ! Ps ::   :: sound :: 'sound_'
by

------- :: nil
E ! nil

E ! Ps
E ! S |- N
-------- :: cons
E ! Ps, S |- N
