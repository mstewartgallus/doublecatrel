embed
{{ coq-preamble
Require Blech.Assoc.
}}
metavar var, x, y ::= {{ coq nat }} {{ coq-equality }} {{ lex alphanum}} {{ tex \mathit{[[var]]} }}

grammar
elim, V :: 'V_' ::= {{ coq-equality }}
  | x              ::   :: var
  | fst V          ::   :: fst
  | snd V          ::   :: snd
  | ( V )          :: S :: paren {{ icho ([[V]]) }}
intro, v :: 'v_' ::= {{ coq-equality }}
  | tt             ::   :: tt
  | v , v'         ::   :: fanout
  | neu ( V )      ::   :: neu {{ tex [ [[V]] ] }}
  | ( v )          :: S :: paren {{ icho ([[v]]) }}

environment, G {{ tex \Gamma }} {{ coq Γ }} :: 'G_' ::= {{ coq (Assoc.assoc type) }}
  | nil         ::   :: nil {{ coq nil }}
  | G , x : t   ::   :: add {{ coq (cons ([[x]], [[t]]) [[G]]) }}
  | ( G )       :: S :: paren {{ coq ([[G]]) }}
  | G ++ G'     :: M :: app {{ coq ([[G]] ++ [[G']]) }}

subst, p {{ tex \rho }} {{ coq ρ }} :: 'p_'  ::= {{ coq (Assoc.assoc intro) }}
  | nil                   :: M :: nil {{ coq nil }}
  | p , x := v            :: M :: add {{ coq (cons ([[x]], [[v]]) [[p]]) }}
  | ( p )                 :: S :: paren {{ coq ([[p]]) }}

funs
  eta_expand ::=
fun
  eta ( t , V ) :: v :: eta {{ tex \eta_{[[t]]} [[V]] }}
by
  eta ( A , V ) === neu( V )
  eta ( unit , V ) === tt
  eta (t1 * t2 , V ) === eta ( t1 , (fst V)), eta ( t2 , (snd V))

defns

find :: '' ::=

defn
x : t \in G ::   :: mem :: 'mem_'
by

----------------- :: eq
x: t \in G, x : t

x != y
x: t \in G
-------------------- :: ne
x: t \in G, y : t'

defns

judge_term :: 'J' ::=

defn
G |- V \infer t ::   :: V :: 'V_'
by

x: t \in G
------------ :: var
G |- x \infer t

G |- V \infer t1 * t2
------------------ :: fst
G |- fst V \infer t1

G |- V \infer t1 * t2
------------------ :: snd
G |- snd V \infer t2

defn
G |- v \check t ::   :: v :: 'v_'
by

--------------- :: tt
G |- tt \check unit

G |- v1 \check t1
G |- v2 \check t2
------------------------- :: fanout
G |- v1, v2 \check t1 * t2

G |- V \infer A
----------------- :: neu
G |- neu ( V) \check A

defns

judge_subst :: 'J' ::=

defn
|- p : G -> G' ::   :: p :: 'p_'
by

-------------- :: id
|- nil: G -> G

G1 |- v \check t
|- p : G2, x: t -> G3
---------------------------- :: cut
|- p, x := v : G2 ++ G1 -> G3

defns

bigV :: '' ::=

defn
p |- V ! v' ::   :: bigV :: 'bigV_'
by

{{ Assoc.find [[x]] [[p]] = Some [[v]] }}
------------------------------------------ :: var
p |- x ! v

p |- V ! v1, v2
----------------- :: fst
p |- fst V ! v1

p |- V ! v1, v2
----------------- :: snd
p |- snd V ! v2

defns

bigv :: '' ::=

defn
p |- v ! v' ::   :: bigv :: 'bigv_'
by

------------- :: tt
p |- tt ! tt

p |- v1 ! v1'
p |- v2 ! v2'
----------------------- :: fanout
p |- v1, v2 ! v1', v2'

p |- V ! v
-------------------- :: neu
p |- neu( V ) ! v
