embed
{{ coq-preamble
Fixpoint zip {A B} (l: list A) (r: list B): list (A * B) :=
 match l, r with
 | cons a l', cons b r' => cons (a, b) (zip l' r')
 | _, _ => nil
 end.

Fixpoint merge (l r: list nat): list nat :=
  match l, r with
  | cons m l', cons n r' => cons (m + n) (merge l' r')
  | _, _ => nil
  end.
}}
metavar var, x, y ::= {{ coq nat }} {{ coq-equality }} {{ lex alphanum}} {{ tex \mathit{[[var]]} }}

grammar
term, v :: 'v_' ::= {{ coq-equality }}
  | x              ::   :: var
  | tt             ::   :: tt
  | fst v          ::   :: fst
  | snd v          ::   :: snd
  | v , v'         ::   :: fanout
  | ( v )          :: S :: paren {{ icho ([[v]]) }}
  | [ x := v ] v'  :: M :: subst {{ icho (subst_term [[v]] [[x]] [[v']]) }}

normal, N :: 'N_' ::= {{ coq-equality }}
  | tt      ::   :: tt
  | N , N'  ::   :: fanout
  | ( N )   :: S :: paren {{ coq ([[N]]) }}

defns

dummy :: '' ::=

defn
dummyfoo ::   :: dum :: 'dum_'
by


grammar

xs :: 'xs_' ::= {{ coq (list var) }}
  | nil                  ::   :: nil {{ coq nil }}
  | xs , x               ::   :: cons {{ coq (cons [[x]] [[xs]]) }}

ts :: 'ts_' ::= {{ coq (list type) }}
  | nil                  ::   :: nil {{ coq nil }}
  | ts , t               ::   :: cons {{ coq (cons [[t]] [[ts]]) }}

environment, G {{ tex \Gamma }} {{ coq Î“ }} :: 'G_' ::= {{ coq (list (var * type)) }}
  | nil         ::   :: nil {{ coq nil }}
  | G , x : t   ::   :: add {{ coq (cons ([[x]], [[t]]) [[G]]) }}
  | ( G )       :: S :: paren {{ coq ([[G]]) }}
  | xs ; ts     :: M :: zip {{ coq (zip [[xs]] [[ts]]) }}

subst, p {{ tex \rho }} {{ coq Ï }} :: 'p_'  ::= {{ coq (list (var * term)) }}
  | nil                   :: M :: nil {{ coq nil }}
  | p , x := v            :: M :: add {{ coq (cons ([[x]], [[v]]) [[p]]) }}
  | ( p )                 :: S :: paren {{ coq ([[p]]) }}

substitutions
  single v x :: subst

% subrules are awkward
funs
  toterm ::=
fun
  [ N ] :: v :: toterm {{ tex \llbracket [[N]] \rrbracket }}
by
  [ tt ] === tt
  [ N, N' ] === [ N ], [ N' ]

embed
{{ coq
Coercion toterm: normal >-> term.
}}

funs
  msubst ::=
fun
  [ := p ] v' :: v :: msubst
by
  [ := nil ] v === v
  [ := p, x := v'] v === [:= p] ([ x := v'] v)

defns

find :: '' ::=

defn
x : t \in G ::   :: mem :: 'mem_'
by

----------------- :: eq
x: t \in G, x : t

x != y
x: t \in G
-------------------- :: ne
x: t \in G, y : t'

defns

judge_term :: 'J' ::=

defn
G |- v : t ::   :: v :: 'v_'
by

x: t \in G
------------ :: var
G |- x: t

------------ :: tt
G |- tt: unit

G |- v1: t1
G |- v2: t2
------------------ :: fanout
G |- v1, v2: t1 * t2

G |- v: t1 * t2
------------------ :: fst
G |- fst v: t1

G |- v: t1 * t2
------------------ :: snd
G |- snd v: t2

defns

big :: '' ::=

defn
v ! N ::   :: big :: 'big_'
by

-------------------- :: tt
tt ! tt

v1 ! N1
v2 ! N2
-------------------- :: fanout
v1, v2 ! N1, N2

v ! N1, N2
-------------------- :: fst
fst v ! N1

v ! N1, N2
------------------- :: snd
snd v ! N2

defns

judge :: 'J' ::=

defn
p : G ::   :: p :: 'p_'
by

---------- :: nil
nil: nil

G |- v : t
p: G
------------------ :: cons
p, x := v: G, x: t
