metavar var, x, y ::= {{ coq nat }} {{ coq-equality }} {{ lex alphanum}} {{ tex \mathit{[[var]]} }}

grammar
term, v :: 'v_' ::=
  | tt             ::   :: tt
  | v , v'         ::   :: fanout
  | neu V          ::   :: neu {{ tex [ [[V]] ] }}
  | ( v )          :: S :: paren {{ icho ([[v]]) }}
  | compare x y v  :: M :: compare {{ coq (match eq_var [[x]] [[y]] with | left _ => [[v]] | right _ => [[v]] end) }}

expr, V :: 'V_' ::=
  | x              ::   :: var
  | fst V          ::   :: fst
  | snd V          ::   :: snd
  | ( V )          :: S :: paren {{ icho ([[V]]) }}

normal, N :: 'N_' ::= {{ coq-equality }}
  | tt      ::   :: tt
  | N , N'  ::   :: fanout
  | ( N )   :: S :: paren {{ coq ([[N]]) }}

grammar

environment, G {{ tex \Gamma }} {{ coq Γ }} :: 'G_' ::= {{ coq (list (var * type)) }}
  | nil         ::   :: nil {{ coq nil }}
  | G , x : t   ::   :: add {{ coq (cons ([[x]], [[t]]) [[G]]) }}
  | ( G )       :: S :: paren {{ coq ([[G]]) }}

subst, p {{ tex \rho }} {{ coq ρ }} :: 'p_'  ::= {{ coq (list (var * normal)) }}
  | nil                   :: M :: nil {{ coq nil }}
  | p , x := N            :: M :: add {{ coq (cons ([[x]], [[N]]) [[p]]) }}
  | ( p )                 :: S :: paren {{ coq ([[p]]) }}

substitutions
  single v x :: subst
  single V x :: subst

% subrules are awkward
funs
  toterm ::=
fun
  [ N ] :: v :: toterm {{ tex \llbracket [[N]] \rrbracket }}
by
  [ tt ] === tt
  [ N, N' ] === [ N ], [ N' ]

embed
{{ coq
Coercion toterm: normal >-> term.
}}

defns

find :: '' ::=

defn
x : t \in G ::   :: mem :: 'mem_'
by

----------------- :: eq
x: t \in G, x : t

x != y
x: t \in G
-------------------- :: ne
x: t \in G, y : t'

defns

judge_term :: 'J' ::=

defn
G |- V : t ::   :: V :: 'V_'
by

x: t \in G
------------ :: var
G |- x: t

G |- V: t1 * t2
------------------ :: fst
G |- fst V: t1

G |- V: t1 * t2
------------------ :: snd
G |- snd V: t2

defn
G |- v : t ::   :: v :: 'v_'
by

--------------- :: tt
G |- tt: unit

G |- v1: t1
G |- v2: t2
------------------ :: fanout
G |- v1, v2: t1 * t2

G |- V: A
---------------- :: neu
G |- neu V : A


defns

judge_subst :: 'J' ::=

defn
p : G ::   :: p :: 'p_'
by

---------- :: nil
nil: nil

nil |- [N] : t
p: G
------------------- :: cons
p, x := N: G, x: t

defns

lookup :: 'mem' ::=

defn
x := N \in p ::   :: p :: 'p_'
by

--------------------- :: eq
x := N \in p, x := N

x != y
x := N \in p
----------------------- :: ne
x := N \in p, y := N'


defns
  hsubstV :: 'hsubstV' ::=
defn
  [ x := v1 ] V === v2 ::   :: '' :: '_'
by

------------------- :: var
[x := v] x === v


[x := v] V === v1, v2
------------------------ :: fst
[x := v] fst V === v1

[x := v] V === v1, v2
------------------------ :: snd
[x := v] snd V === v2

defns
  hsubstVV :: 'hsubstVV' ::=
defn
  [ x := v ] V === V' ::   :: '' :: '_'
by

x != y
-------------------- :: var
[ x := v ] y === y

[x := v] V === V'
------------------------- :: fst
[x := v] fst V === fst V'

[x := v] V === V'
------------------------- :: snd
[x := v] snd V === snd V'

defns
  hsubstv :: 'hsubstv' ::=
defn
  [ x := v1 ] v2 === v3 ::   :: '' :: '_'
by

-------------------- :: tt
[ x := v ] tt === tt

[x := v] v1 === v1'
[x := v] v2 === v2'
------------------------------- :: fanout
[ x := v ] (v1, v2) === v1', v2'

[x := v] V === v'
--------------------- :: neu
[x := v] neu V === v'

defns

big :: 'big' ::=

defn
p |- v ! N ::   :: v :: 'v_'
by

-------------- :: tt
p |- tt ! tt

p |- v1 ! N1
p |- v2 ! N2
-------------------- :: fanout
p |- v1, v2 ! N1, N2

p |- V ! N
------------- :: neu
p |- neu V ! N

defn
p |- V ! N ::   :: V :: 'V_'
by

x := N \in p
------------- :: var
p |- x ! N

p |- V ! N1, N2
---------- :: fst
p |- fst V ! N1

p |- V ! N1, N2
---------- :: snd
p |- snd V ! N2
