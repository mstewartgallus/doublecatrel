embed
{{ coq-preamble
Require Blech.Map.
}}
grammar

context, E :: 'E_' ::= {{ coq-equality }}
  | x                        ::   :: var
  | lam x : t . E            ::   :: lam (+ bind x in E +)
  | E E'                     ::   :: app
  | tt                       ::   :: tt
  | E ; E'                   ::   :: step
  | E , E'                   ::   :: fanout
  | let x , y = E in E'      ::   :: let (+ bind x union y in E' +)
  | ( E )                    :: S :: paren {{ icho ([[E]]) }}

use, u :: 'u_' ::= {{ coq-equality }}
  | 1 ::  :: used
  | 0 ::  :: unused

usage, D {{ tex \Delta }} {{ coq Δ }} :: 'D_' ::= {{ coq (list use) }}
  | nil                  ::   :: nil {{ coq nil }}
  | D , u                ::   :: cons {{ coq (cons [[u]] [[D]]) }}

nat, n :: 'n_' ::= {{ coq nat }}
  | 0          ::  :: zero {{ coq 0 }}
  | S n        ::  :: succ {{ coq (S [[n]]) }} {{ tex [[n]] + 1 }}
  | 1          :: M :: one {{ coq 1 }}
  | len xs     :: M :: lenxs {{ coq (length [[xs]]) }}
  | len G      :: M :: lenG {{ coq (length [[G]]) }}
  | len D      :: M :: lenD {{ coq (length [[D]]) }}
  | ( n )      :: S :: paren {{ icho ([[n]]) }}

store, S {{ tex \sigma }} {{ coq σ }} :: 'S_'  ::= {{ coq (Map.map normal) }}
  | nil                   :: M :: empty {{ coq (Map.empty) }}
  | x := N                :: M :: one {{ coq (Map.one [[x]] [[N]]) }}
  | S , S'                :: M :: add {{ coq (Map.merge [[S']] [[S]]) }}
  | S ++ S'               :: M :: merge {{ coq (Map.merge [[S]] [[S']]) }}

span, P :: 'P_' ::=
  | S |- N  ::   :: with

set, Ps {{ tex P^* }} :: 'X_' ::= {{ coq (list span) }}
  | nil          ::   :: nil {{ coq nil }}
  | Ps , P       ::   :: cons {{ coq (cons [[P]] [[Ps]]) }}

vars, xs {{ tex x^* }} :: 'xs_' ::= {{ coq (list var) }}
  | nil          ::   :: nil {{ coq nil }}
  | xs , x       ::   :: cons {{ coq (cons [[x]] [[xs]]) }}
  | ( xs )       :: S :: paren {{ coq ([[xs]]) }}

terminals :: 'terminals_' ::=
  | :            ::   :: in     {{ tex \colon{} }}
  | |-           ::   :: turnstile   {{ tex \vdash{} }}
  | :=           ::   :: update  {{ tex \mathbin{:=} }}
  | ->           ::   :: to  {{ tex \rightarrow }}
  | unit         ::   :: unit  {{ tex \textbf{I} }}
  | *            ::   :: prod  {{ tex \otimes{} }}
  | tt           ::   :: tt   {{ tex \mathop{ \textbf ! } }}
  | fst          ::   :: fst  {{ tex \pi{}_1 }}
  | snd          ::   :: snd  {{ tex \pi{}_2 }}
  | lam          ::   :: lam  {{ tex \lambda{} }}
  | nil          ::   :: nil   {{ tex \bullet{} }}
  | let          ::   :: let  {{ tex \mathbin{\textbf{let} } }}
  | in           ::   :: letin  {{ tex \mathbin{\textbf{in} } }}
  | \in          ::   :: member  {{ tex \mathrel{\in} }}
  | once         ::   :: once  {{ tex \mathrel{\in!} }}
  | never        ::   :: never  {{ tex \mathrel{\notin} }}
  | !            ::   :: big     {{ tex \mathrel{\Downarrow} }}
  | !=           ::   :: ne     {{ tex \mathrel{\ne} }}
  | ==           ::   :: equiv   {{ tex \mathrel{\sim} }}

parsing
  S_add left S_add

substitutions
  single E x :: subst

grammar
formula :: formula_ ::=  
 | judgement                        ::   :: judgement
 | x != y                           :: M :: neqx {{ icho ([[x]] <> [[y]]) }}
 | x = y                            :: M :: eqx {{ icho ([[x]] = [[y]]) }}
 | n = n'                           :: M :: eqn {{ icho ([[n]] = [[n']]) }}

funs
  empty ::=
fun
  mt n :: D :: mt {{ tex \emptyset_{[[n]]} }}
by
  mt 0 === nil
  mt S n === mt n, 0

funs
  xsofG ::=
fun
  xsof G :: xs :: xsof
by
  xsof nil === nil
  xsof (G , x : t) === xsof G , x

defns

lfind :: '' ::=

defn
x \in xs ; D -> D' ::   :: lmem :: 'lmem_'
by

len xs = len D
---------------------------- :: eq
x \in xs, x ; D, 0 -> D, 1

x != y
x \in xs ; D -> D'
---------------------------- :: ne
x \in xs, y ; D, u -> D', u

defns

judge_context :: 'J' ::=

defn
G ; D -> D' |- E : t ::   :: E :: 'E_'
by

x: t \in G
x \in xsof G ; D -> D'
----------------------- :: var
G ; D -> D' |- x: t

G, x: t1 ; D, 0 -> D', 1 |- E: t2
------------------------------- :: lam
G ; D -> D' |- lam x: t1 . E: t1 * t2

G ; D1 -> D2 |- E1: t1 * t2
G ; D2 -> D3 |- E2: t1
--------------------------------- :: app
G ; D1 -> D3 |- E1 E2: t2

len G = len D
-------------------------------- :: tt
G ; D -> D |- tt: unit

G ; D1 -> D2 |- E1: unit
G ; D2 -> D3 |- E2: t
------------------------- :: step
G ; D1 -> D3 |- E1; E2: t

G ; D1 -> D2 |- E1: t1
G ; D2 -> D3 |- E2: t2
------------------------------- :: fanout
G ; D1 -> D3 |- E1, E2: t1 * t2

G ; D1 -> D2 |- E1 : t1 * t2
G, x: t1, y: t2 ; D2, 0, 0 -> D3, 1, 1 |- E2: t3
------------------------------------------------- :: let
G ; D1 -> D3 |- let x, y = E1 in E2: t3

defns

sat :: '' ::= {{ coq-universe Type }}

defn
S |- E [ N ] ::   :: sat :: 'sat_' {{ tex [[S]] \mathrel{\vdash} [[E]] [ [[N]] ] }}
by

---------------------- :: var
x := N |- x [ N ]

------------------ :: tt
nil |- tt [tt]

S |- E [ tt ]
S' |- E' [ N ]
-------------------------- :: step
S ++ S' |- (E; E') [ N ]

S |-  E [N]
S' |-  E' [N']
-------------------------- :: fanout
S ++ S' |- (E, E') [N, N']

S |- E [N0, N1]
S', x := N0, y := N1 |- E' [ N2 ]
------------------------------------- :: let
S ++ S' |- (let x, y = E in E') [ N2 ]

S, x := N |- E [ N' ]
------------------------- :: lam
S |- (lam x: t. E) [ N, N' ]

S |- E [ N, N' ]
S' |- E' [N]
--------------------- :: app
S ++ S' |- (E E') [ N' ]

defns

sound :: '' ::= {{ coq-universe Type }}

defn
E [ Ps ] ::   :: sound :: 'sound_'
by

----------- :: nil
E [ nil ]

E [ Ps ]
S |- E [N]
---------------- :: cons
E [ Ps, S |- N ]
