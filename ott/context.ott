embed
{{ coq-preamble
Require Blech.Map.
}}
grammar

context, E :: 'E_' ::=
  | lam x . E                ::   :: lam (+ bind x in E +)
  | tt                       ::   :: tt
  | E , E'                   ::   :: fanout
  | neu e                    ::   :: neu {{ tex [ [[e]] ] }}
  | ( E )                    :: S :: paren {{ icho ([[E]]) }}

redex, e :: 'e_' ::=
  | x                        ::   :: var
  | e E'                     ::   :: app
  | e ; E' : t               ::   :: step
  | let x , y = e in E' : t  ::   :: let (+ bind x union y in E' +)
  | cut E t                  ::   :: cut {{ tex [[E]] \colon [[t]] }}
  | ( e )                    :: S :: paren {{ icho ([[e]]) }}

use, u :: 'u_' ::= {{ coq-equality }}
  | used   ::  :: used
  | unused ::  :: unused

usage, D {{ tex \Delta }} {{ coq Δ }} :: 'D_' ::= {{ coq (Assoc.assoc use) }}
  | nil                  ::   :: nil {{ coq nil }}
  | D , x [ u ]          ::   :: cons {{ coq (cons ([[x]], [[u]]) [[D]]) }}

nat, n :: 'n_' ::= {{ coq nat }}
  | 0          ::  :: zero {{ coq 0 }}
  | S n        ::  :: succ {{ coq (S [[n]]) }} {{ tex [[n]] + 1 }}
  | len xs     :: M :: lenxs {{ coq (length [[xs]]) }}
  | len G      :: M :: lenG {{ coq (length [[G]]) }}
  | len D      :: M :: lenD {{ coq (length [[D]]) }}
  | ( n )      :: S :: paren {{ icho ([[n]]) }}

store, S {{ tex \sigma }} {{ coq σ }} :: 'S_'  ::= {{ coq (Map.map intro) }}
  | nil                   :: M :: empty {{ coq (Map.empty) }}
  | x := v            :: M :: one {{ coq (Map.one [[x]] [[v]]) }}
  | S , S'                :: M :: add {{ coq (Map.merge [[S']] [[S]]) }}
  | S ++ S'               :: M :: merge {{ coq (Map.merge [[S]] [[S']]) }}

span, P :: 'P_' ::=
  | S |- v  ::   :: with

spans, Ps {{ tex P^* }} :: 'Ps_' ::= {{ coq (list span) }}
  | nil          ::   :: nil {{ coq nil }}
  | Ps , P       ::   :: cons {{ coq (cons [[P]] [[Ps]]) }}

stores, Ss {{ tex S^* }} :: 'Ss_' ::= {{ coq (list store) }}
  | nil          ::   :: nil {{ coq nil }}
  | Ss , S       ::   :: cons {{ coq (cons [[S]] [[Ss]]) }}

vars, xs {{ tex x^* }} :: 'xs_' ::= {{ coq (list var) }}
  | nil          ::   :: nil {{ coq nil }}
  | xs , x       ::   :: cons {{ coq (cons [[x]] [[xs]]) }}
  | ( xs )       :: S :: paren {{ coq ([[xs]]) }}

terminals :: 'terminals_' ::=
  | :            ::   :: in     {{ tex \colon{} }}
  | |-           ::   :: turnstile   {{ tex \vdash{} }}
  | ===          ::   :: eequiv   {{ tex \equiv{} }}
  | :=           ::   :: update  {{ tex \mathbin{:=} }}
  | ->           ::   :: to  {{ tex \rightarrow }}
  | &            ::   :: act  {{ tex \cdot }}
  | @            ::   :: compose  {{ tex \circ }}
  | unit         ::   :: unit  {{ tex \textbf{I} }}
  | *            ::   :: prod  {{ tex \otimes{} }}
  | used         ::   :: used  {{ tex \textbf{s} }}
  | unused       ::   :: unused  {{ tex \textbf{f} }}
  | tt           ::   :: tt   {{ tex \mathop{ \textbf ! } }}
  | fst          ::   :: fst  {{ tex \pi{}_1 }}
  | snd          ::   :: snd  {{ tex \pi{}_2 }}
  | lam          ::   :: lam  {{ tex \lambda{} }}
  | nil          ::   :: nil   {{ tex \bullet{} }}
  | let          ::   :: let  {{ tex \mathbin{\textbf{let} } }}
  | in           ::   :: letin  {{ tex \mathbin{\textbf{in} } }}
  | \in          ::   :: member  {{ tex \mathrel{\in} }}
  | \infer       ::   :: infer  {{ tex \Rightarrow }}
  | \check       ::   :: check  {{ tex \Leftarrow }}
  | once         ::   :: once  {{ tex \mathrel{\in!} }}
  | never        ::   :: never  {{ tex \mathrel{\notin} }}
  | ++            ::   :: merge  {{ tex \mathrel{\cup} }}
  | !            ::   :: big     {{ tex \mathrel{\Downarrow} }}
  | !=           ::   :: ne     {{ tex \mathrel{\ne} }}
  | ==           ::   :: equiv   {{ tex \mathrel{\sim} }}

parsing
  S_add left S_add

substitutions
  single E x :: subst
  single e x :: subst
  single V x :: subst
  single v x :: subst
  single P x :: subst


grammar
formula :: formula_ ::=  
 | judgement                        ::   :: judgement
 | x != y                           :: M :: neqx {{ icho ([[x]] <> [[y]]) }}
 | x = y                            :: M :: eqx {{ icho ([[x]] = [[y]]) }}
 | n = n'                           :: M :: eqn {{ icho ([[n]] = [[n']]) }}

funs
  xsofG ::=
fun
  xsof G :: xs :: xsof
by
  xsof nil === nil
  xsof (G , x : t) === xsof G , x

defns

lfind :: '' ::=

defn
x \in D -> D' ::   :: lmem :: 'lmem_'
by

-------------------------------------- :: eq
x \in D, x [ unused ] -> D, x [ used ]

x != y
x \in D -> D'
-------------------------------- :: ne
x \in D, y [ u ] -> D', y [ u ]

defns

scope :: '' ::=

defn
  D -> D' |- e ::   :: se :: 'se_'
by

x \in D -> D'
------------- :: var
D -> D' |- x

D1 -> D2 |- e1
D2 -> D3 |- E2
------------------ :: app
D1 -> D3 |- e1 E2

D1 -> D2 |- e1
D2 -> D3 |- E2
----------------------- :: step
D1 -> D3 |- e1; E2 : t

D1 -> D2 |- e1
D2, x [unused], y[unused] -> D3, x[used], y[used] |- E2
------------------------------------------------------ :: let
D1 -> D3 |- let x, y = e1 in E2 : t3

D -> D' |- E
------------------- :: cut
D -> D' |- cut E t

defn
  D -> D' |- E ::   :: sE :: 'sE_'
by

D, x[unused] -> D', x[used] |- E
------------------------------ :: lam
D -> D' |- lam x . E

-------------- :: tt
D -> D |- tt

D1 -> D2 |- E1
D2 -> D3 |- E2
-------------------- :: fanout
D1 -> D3 |- E1, E2

D -> D' |- e
------------------- :: neu
D -> D' |- neu e

defns

judge_context :: '' ::=

defn
G  |- e \infer t ::   :: infer :: 'infer_'
by

x: t \in G
----------------------- :: var
G |- x \infer t

G |- e1 \infer t1 * t2
G |- E2 \check t1
--------------------------------- :: app
G |- e1 E2 \infer t2

G |- e1 \infer unit
G |- E2 \check t
---------------------------------- :: step
G |- e1; E2 : t \infer t

G |- e1 \infer t1 * t2
G, x: t1, y: t2 |- E2 \check t3
------------------------------------------------- :: let
G |- let x, y = e1 in E2 : t3 \infer t3

G |- E \check t
---------------------------------- :: cut
G |- cut E t \infer t

defn
G |- E \check t ::   :: check :: 'check_'
by

G, x: t1 |- E \check t2
---------------------------------------- :: lam
G |- lam x . E \check t1 * t2

-------------------- :: tt
G |- tt \check unit

G |- E1 \check t1
G |- E2 \check t2
---------------------------- :: fanout
G |- E1, E2 \check t1 * t2

G |- e \infer t
---------------------- :: neu
G |- neu e \check t

defns

sat :: '' ::= {{ coq-universe Type }}

defn
S |- e [ v ] ::   :: produces :: 'produces_' {{ tex [[S]] \mathrel{\vdash} [[e]] [ [[v]] ] }}
by

-------------------------- :: var
x := v |- x [ v ]

S |- e [ tt ]
S' |- E' [ v ]
------------------------------- :: step
S ++ S' |- (e; E': t) [ v ]

S |- e [v0, v1]
S', x := v0, y := v1 |- E' [ v2 ]
------------------------------------------------ :: let
S ++ S' |- (let x, y = e in E' : t) [ v2 ]

S |- e [ v, v' ]
S' |- E' [v]
----------------------------- :: app
S ++ S' |- (e E') [ v' ]

S |- E [ v ]
------------------------- :: cut
S |- (cut E t) [ v ]

defn
S |- E [ v ] ::   :: accepts :: 'accepts_' {{ tex [[S]] \mathrel{\vdash} [[E]] [ [[v]] ] }}
by

--------------- :: tt
nil |- tt [tt]

S |- E [v]
S' |- E' [v']
--------------------------- :: fanout
S ++ S' |- (E, E') [v, v']

S, x := v |- E [ v' ]
------------------------------------ :: lam
S |- (lam x. E) [ v, v' ]

S |- e [ v ]
--------------------------- :: neu
S |- (neu e) [ v ]

defns

sound :: '' ::= {{ coq-universe Type }}

defn
E [ Ss ; v ] ::   :: sound :: 'sound_'
by

------------- :: nil
E [ nil ; v ]

E [ Ss ; v ]
S |- E [v]
----------------- :: cons
E [ Ss, S ; v ]


defn
e [ Ps ] ::   :: sounde :: 'sounde_'
by

-------------- :: nil
e [ nil ]

e [ Ps ]
S |- e [v]
-------------------- :: cons
e [ Ps , S |- v ]
