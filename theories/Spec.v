(* generated by Ott 0.31 from: ott/context.ott ott/term.ott ott/type.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import Ott.ott_list_core.


Definition tyvar : Set := nat.
Lemma eq_tyvar: forall (x y : tyvar), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_tyvar : ott_coq_equality.

Inductive type : Set := 
 | t_var (A:tyvar)
 | t_unit : type
 | t_prod (t:type) (t':type).
Lemma eq_type: forall (x y : type), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_type : ott_coq_equality.
Definition var : Set := nat.
Lemma eq_var: forall (x y : var), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_var : ott_coq_equality.

Inductive normal : Set := 
 | N_tt : normal
 | N_fanout (N:normal) (N':normal).

Inductive expr : Set := 
 | V_var (x:var)
 | V_fst (V:expr)
 | V_snd (V:expr).

Definition subst : Set := (list (var * normal)).

Definition environment : Set := (list (var * type)).

Inductive term : Set := 
 | v_tt : term
 | v_fanout (v:term) (v':term)
 | v_neu (V:expr).
Lemma eq_normal: forall (x y : normal), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_normal : ott_coq_equality.

(** substitutions *)
Fixpoint subst_expr (V5:expr) (x5:var) (V_6:expr) {struct V_6} : expr :=
  match V_6 with
  | (V_var x) => (if eq_var x x5 then V5 else (V_var x))
  | (V_fst V) => V_fst (subst_expr V5 x5 V)
  | (V_snd V) => V_snd (subst_expr V5 x5 V)
end.

Fixpoint subst_term (V5:expr) (x5:var) (v5:term) {struct v5} : term :=
  match v5 with
  | v_tt => v_tt 
  | (v_fanout v v') => v_fanout (subst_term V5 x5 v) (subst_term V5 x5 v')
  | (v_neu V) => v_neu (subst_expr V5 x5 V)
end.

(** definitions *)

(** funs toterm *)
Fixpoint toterm (x1:normal) : term:=
  match x1 with
  | N_tt => v_tt
  | (N_fanout N N') => (v_fanout  (toterm N )   (toterm N' ) )
end.

Coercion toterm: normal >-> term.

(** definitions *)

(* defns find *)
Inductive mem : var -> type -> environment -> Prop :=    (* defn mem *)
 | mem_eq : forall (x:var) (t:type) (Γ:environment),
     mem x t  (cons ( x ,  t )  Γ ) 
 | mem_ne : forall (x:var) (t:type) (Γ:environment) (y:var) (t':type),
      ( x  <>  y )  ->
     mem x t Γ ->
     mem x t  (cons ( y ,  t' )  Γ ) .
(** definitions *)

(* defns judge_term *)
Inductive JV : environment -> expr -> type -> Prop :=    (* defn V *)
 | JV_var : forall (Γ:environment) (x:var) (t:type),
     mem x t Γ ->
     JV Γ (V_var x) t
 | JV_fst : forall (Γ:environment) (V:expr) (t1 t2:type),
     JV Γ V (t_prod t1 t2) ->
     JV Γ (V_fst V) t1
 | JV_snd : forall (Γ:environment) (V:expr) (t2 t1:type),
     JV Γ V (t_prod t1 t2) ->
     JV Γ (V_snd V) t2
with Jv : environment -> term -> type -> Prop :=    (* defn v *)
 | Jv_tt : forall (Γ:environment),
     Jv Γ v_tt t_unit
 | Jv_fanout : forall (Γ:environment) (v1 v2:term) (t1 t2:type),
     Jv Γ v1 t1 ->
     Jv Γ v2 t2 ->
     Jv Γ (v_fanout v1 v2) (t_prod t1 t2)
 | Jv_neu : forall (Γ:environment) (V:expr) (A:tyvar),
     JV Γ V (t_var A) ->
     Jv Γ (v_neu V) (t_var A).
(** definitions *)

(* defns judge_subst *)
Inductive Jp : subst -> environment -> Prop :=    (* defn p *)
 | Jp_nil : 
     Jp  nil   nil 
 | Jp_cons : forall (ρ:subst) (x:var) (N:normal) (Γ:environment) (t:type),
     Jv  nil   (toterm N )  t ->
     Jp ρ Γ ->
     Jp  (cons ( x ,  N )  ρ )   (cons ( x ,  t )  Γ ) .
(** definitions *)

(* defns lookup *)
Inductive memp : var -> normal -> subst -> Prop :=    (* defn p *)
 | memp_eq : forall (x:var) (N:normal) (ρ:subst),
     memp x N  (cons ( x ,  N )  ρ ) 
 | memp_ne : forall (x:var) (N:normal) (ρ:subst) (y:var) (N':normal),
      ( x  <>  y )  ->
     memp x N ρ ->
     memp x N  (cons ( y ,  N' )  ρ ) .
(** definitions *)

(* defns hsubstV *)
Inductive hsubstV : var -> term -> expr -> term -> Prop :=    (* defn  *)
 | hsubstV_var : forall (x:var) (v:term),
     hsubstV x v (V_var x) v
 | hsubstV_fst : forall (x:var) (v:term) (V:expr) (v1 v2:term),
     hsubstV x v V (v_fanout v1 v2) ->
     hsubstV x v (V_fst V) v1
 | hsubstV_snd : forall (x:var) (v:term) (V:expr) (v2 v1:term),
     hsubstV x v V (v_fanout v1 v2) ->
     hsubstV x v (V_snd V) v2.
(** definitions *)

(* defns hsubstVV *)
Inductive hsubstVV : var -> term -> expr -> expr -> Prop :=    (* defn  *)
 | hsubstVV_var : forall (x:var) (v:term) (y:var),
      ( x  <>  y )  ->
     hsubstVV x v (V_var y) (V_var y)
 | hsubstVV_fst : forall (x:var) (v:term) (V V':expr),
     hsubstVV x v V V' ->
     hsubstVV x v (V_fst V) (V_fst V')
 | hsubstVV_snd : forall (x:var) (v:term) (V V':expr),
     hsubstVV x v V V' ->
     hsubstVV x v (V_snd V) (V_snd V').
(** definitions *)

(* defns hsubstv *)
Inductive hsubstv : var -> term -> term -> term -> Prop :=    (* defn  *)
 | hsubstv_tt : forall (x:var) (v:term),
     hsubstv x v v_tt v_tt
 | hsubstv_fanout : forall (x:var) (v v1 v2 v1' v2':term),
     hsubstv x v v1 v1' ->
     hsubstv x v v2 v2' ->
     hsubstv x v  ( (v_fanout v1 v2) )  (v_fanout v1' v2')
 | hsubstv_neu : forall (x:var) (v:term) (V:expr) (v':term),
     hsubstV x v V v' ->
     hsubstv x v (v_neu V) v'.
(** definitions *)

(* defns big *)
Inductive bigv : subst -> term -> normal -> Prop :=    (* defn v *)
 | bigv_tt : forall (ρ:subst),
     bigv ρ v_tt N_tt
 | bigv_fanout : forall (ρ:subst) (v1 v2:term) (N1 N2:normal),
     bigv ρ v1 N1 ->
     bigv ρ v2 N2 ->
     bigv ρ (v_fanout v1 v2) (N_fanout N1 N2)
 | bigv_neu : forall (ρ:subst) (V:expr) (N:normal),
     bigV ρ V N ->
     bigv ρ (v_neu V) N
with bigV : subst -> expr -> normal -> Prop :=    (* defn V *)
 | bigV_var : forall (ρ:subst) (x:var) (N:normal),
     memp x N ρ ->
     bigV ρ (V_var x) N
 | bigV_fst : forall (ρ:subst) (V:expr) (N1 N2:normal),
     bigV ρ V (N_fanout N1 N2) ->
     bigV ρ (V_fst V) N1
 | bigV_snd : forall (ρ:subst) (V:expr) (N2 N1:normal),
     bigV ρ V (N_fanout N1 N2) ->
     bigV ρ (V_snd V) N2.
Require Blech.Map.


Definition store : Set := (Map.map normal).

Inductive span : Set := 
 | P_with (σ:store) (N:normal).

Inductive use : Set := 
 | u_used : use
 | u_unused : use.

Inductive context : Set := 
 | E_lam (x:var) (E:context)
 | E_tt : context
 | E_fanout (E:context) (E':context)
 | E_neu (e:redex)
with redex : Set := 
 | e_var (x:var)
 | e_app (e:redex) (E':context)
 | e_step (e:redex) (E':context) (t:type)
 | e_let (x:var) (y:var) (e:redex) (E':context) (t:type)
 | e_cut (E:context) (t:type).

Definition stores : Set := (list store).

Definition spans : Set := (list span).

Definition usage : Set := (list use).

Definition vars : Set := (list var).

Definition nat : Set := nat.
Lemma eq_use: forall (x y : use), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_use : ott_coq_equality.
(** library functions *)
Fixpoint list_mem A (eq:forall a b:A,{a=b}+{a<>b}) (x:A) (l:list A) {struct l} : bool :=
  match l with
  | nil => false
  | cons h t => if eq h x then true else list_mem A eq x t
end.
Arguments list_mem [A] _ _ _.


(** substitutions *)
Fixpoint subst_redex (e5:redex) (x5:var) (e_6:redex) {struct e_6} : redex :=
  match e_6 with
  | (e_var x) => (if eq_var x x5 then e5 else (e_var x))
  | (e_app e E') => e_app (subst_redex e5 x5 e) (subst_context e5 x5 E')
  | (e_step e E' t) => e_step (subst_redex e5 x5 e) (subst_context e5 x5 E') t
  | (e_let x y e E' t) => e_let x y (subst_redex e5 x5 e) (if list_mem eq_var x5 (app (cons x nil) (cons y nil)) then E' else (subst_context e5 x5 E')) t
  | (e_cut E t) => e_cut (subst_context e5 x5 E) t
end
with subst_context (e5:redex) (x5:var) (E5:context) {struct E5} : context :=
  match E5 with
  | (E_lam x E) => E_lam x (if list_mem eq_var x5 (cons x nil) then E else (subst_context e5 x5 E))
  | E_tt => E_tt 
  | (E_fanout E E') => E_fanout (subst_context e5 x5 E) (subst_context e5 x5 E')
  | (E_neu e) => E_neu (subst_redex e5 x5 e)
end.

(** definitions *)

(** funs empty *)
Fixpoint mt (x1:nat) : usage:=
  match x1 with
  |  0  =>  nil 
  |  (S  n )  =>  (cons  u_unused    (mt n )  ) 
end.

(** definitions *)

(** funs xsofG *)
Fixpoint xsof (x1:environment) : vars:=
  match x1 with
  |  nil  =>  nil 
  |  (  (cons ( x ,  t )  Γ )  )  =>  (cons  x    (xsof Γ )  ) 
end.

(** definitions *)

(* defns lfind *)
Inductive lmem : var -> vars -> usage -> usage -> Prop :=    (* defn lmem *)
 | lmem_eq : forall (xs:vars) (x:var) (Δ:usage),
      (  (length  xs )   =   (length  Δ )  )  ->
     lmem x  (cons  x   xs )   (cons  u_unused   Δ )   (cons  u_used   Δ ) 
 | lmem_ne : forall (xs:vars) (x y:var) (Δ:usage) (u:use) (Δ':usage),
      ( x  <>  y )  ->
     lmem x xs Δ Δ' ->
     lmem x  (cons  y   xs )   (cons  u   Δ )   (cons  u   Δ' ) .
(** definitions *)

(* defns judge_context *)
Inductive infer : environment -> usage -> usage -> redex -> type -> Prop :=    (* defn infer *)
 | infer_var : forall (Γ:environment) (Δ Δ':usage) (x:var) (t:type),
     mem x t Γ ->
     lmem x  (xsof Γ )  Δ Δ' ->
     infer Γ Δ Δ' (e_var x) t
 | infer_app : forall (Γ:environment) (Δ1 Δ3:usage) (e1:redex) (E2:context) (t2:type) (Δ2:usage) (t1:type),
     infer Γ Δ1 Δ2 e1 (t_prod t1 t2) ->
     check Γ Δ2 Δ3 E2 t1 ->
     infer Γ Δ1 Δ3 (e_app e1 E2) t2
 | infer_step : forall (Γ:environment) (Δ1 Δ3:usage) (e1:redex) (E2:context) (t:type) (Δ2:usage),
     infer Γ Δ1 Δ2 e1 t_unit ->
     check Γ Δ2 Δ3 E2 t ->
     infer Γ Δ1 Δ3 (e_step e1 E2 t) t
 | infer_let : forall (Γ:environment) (Δ1 Δ3:usage) (x y:var) (e1:redex) (E2:context) (t3:type) (Δ2:usage) (t1 t2:type),
     infer Γ Δ1 Δ2 e1 (t_prod t1 t2) ->
     check  (cons ( y ,  t2 )   (cons ( x ,  t1 )  Γ )  )   (cons  u_unused    (cons  u_unused   Δ2 )  )   (cons  u_used    (cons  u_used   Δ3 )  )  E2 t3 ->
     infer Γ Δ1 Δ3 (e_let x y e1 E2 t3) t3
 | infer_cut : forall (Γ:environment) (Δ Δ':usage) (E:context) (t:type),
     check Γ Δ Δ' E t ->
     infer Γ Δ Δ' (e_cut E t) t
with check : environment -> usage -> usage -> context -> type -> Prop :=    (* defn check *)
 | check_lam : forall (Γ:environment) (Δ Δ':usage) (x:var) (E:context) (t1 t2:type),
     check  (cons ( x ,  t1 )  Γ )   (cons  u_unused   Δ )   (cons  u_used   Δ' )  E t2 ->
     check Γ Δ Δ' (E_lam x E) (t_prod t1 t2)
 | check_tt : forall (Γ:environment) (Δ:usage),
      (  (length  Γ )   =   (length  Δ )  )  ->
     check Γ Δ Δ E_tt t_unit
 | check_fanout : forall (Γ:environment) (Δ1 Δ3:usage) (E1 E2:context) (t1 t2:type) (Δ2:usage),
     check Γ Δ1 Δ2 E1 t1 ->
     check Γ Δ2 Δ3 E2 t2 ->
     check Γ Δ1 Δ3 (E_fanout E1 E2) (t_prod t1 t2)
 | check_neu : forall (Γ:environment) (Δ Δ':usage) (e:redex) (t:type),
     infer Γ Δ Δ' e t ->
     check Γ Δ Δ' (E_neu e) t.
(** definitions *)

(* defns sat *)
Inductive produces : store -> redex -> normal -> Type :=    (* defn produces *)
 | produces_var : forall (x:var) (N:normal),
     produces  (Map.one  x   N )  (e_var x) N
 | produces_step : forall (σ σ':store) (e:redex) (E':context) (t:type) (N:normal),
     produces σ e N_tt ->
     accepts σ' E' N ->
     produces  (Map.merge  σ   σ' )   ( (e_step e E' t) )  N
 | produces_let : forall (σ σ':store) (x y:var) (e:redex) (E':context) (t:type) (N2 N0 N1:normal),
     produces σ e (N_fanout N0 N1) ->
     accepts  (Map.merge   (Map.one  y   N1 )     (Map.merge   (Map.one  x   N0 )    σ' )  )  E' N2 ->
     produces  (Map.merge  σ   σ' )   ( (e_let x y e E' t) )  N2
 | produces_app : forall (σ σ':store) (e:redex) (E':context) (N' N:normal),
     produces σ e (N_fanout N N') ->
     accepts σ' E' N ->
     produces  (Map.merge  σ   σ' )   ( (e_app e E') )  N'
 | produces_cut : forall (σ:store) (E:context) (t:type) (N:normal),
     accepts σ E N ->
     produces σ  ( (e_cut E t) )  N
with accepts : store -> context -> normal -> Type :=    (* defn accepts *)
 | accepts_tt : 
     accepts  (Map.empty)  E_tt N_tt
 | accepts_fanout : forall (σ σ':store) (E E':context) (N N':normal),
     accepts σ E N ->
     accepts σ' E' N' ->
     accepts  (Map.merge  σ   σ' )   ( (E_fanout E E') )  (N_fanout N N')
 | accepts_lam : forall (σ:store) (x:var) (E:context) (N N':normal),
     accepts  (Map.merge   (Map.one  x   N )    σ )  E N' ->
     accepts σ  ( (E_lam x E) )  (N_fanout N N')
 | accepts_neu : forall (σ:store) (e:redex) (N:normal),
     produces σ e N ->
     accepts σ  ( (E_neu e) )  N.
(** definitions *)

(* defns sound *)
Inductive sound : context -> stores -> normal -> Type :=    (* defn sound *)
 | sound_nil : forall (E:context) (N:normal),
     sound E  nil  N
 | sound_cons : forall (E:context) (Ss:stores) (σ:store) (N:normal),
     sound E Ss N ->
     accepts σ E N ->
     sound E  (cons  σ   Ss )  N
with sounde : redex -> spans -> Type :=    (* defn sounde *)
 | sounde_nil : forall (e:redex),
     sounde e  nil 
 | sounde_cons : forall (e:redex) (Ps:spans) (σ:store) (N:normal),
     sounde e Ps ->
     produces σ e N ->
     sounde e  (cons  (P_with σ N)   Ps ) .


