(* generated by Ott 0.31 from: ott/test.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import Ott.ott_list_core.


Require Blech.Map.

Definition var : Set := nat.
Lemma eq_var: forall (x y : var), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_var : ott_coq_equality.

Definition store : Type := (Map.map normal).

Inductive normal : Set := 
 | N_tt : normal
 | N_fanout (N:normal) (N':normal).

Inductive type : Set := 
 | t_unit : type
 | t_prod (t:type) (t':type).

Inductive span : Type := 
 | P_with (S:store) (N:normal).

Inductive term : Set := 
 | v_var (x:var)
 | v_tt : term
 | v_fst (v:term)
 | v_snd (v:term)
 | v_fanout (v:term) (v':term).

Inductive context : Set := 
 | E_var (x:var)
 | E_lam (x:var) (t:type) (E:context)
 | E_app (E:context) (E':context)
 | E_tt : context
 | E_step (E:context) (E':context)
 | E_fanout (E:context) (E':context)
 | E_let (x:var) (y:var) (E:context) (E':context).

Definition linear : Type := (Map.map type).

Definition environment : Set := (list (var * type)).

Definition set : Type := (list span).
(** library functions *)
Fixpoint list_mem A (eq:forall a b:A,{a=b}+{a<>b}) (x:A) (l:list A) {struct l} : bool :=
  match l with
  | nil => false
  | cons h t => if eq h x then true else list_mem A eq x t
end.
Arguments list_mem [A] _ _ _.


(** substitutions *)
Fixpoint subst_term (v5:term) (x5:var) (v_6:term) {struct v_6} : term :=
  match v_6 with
  | (v_var x) => (if eq_var x x5 then v5 else (v_var x))
  | v_tt => v_tt 
  | (v_fst v) => v_fst (subst_term v5 x5 v)
  | (v_snd v) => v_snd (subst_term v5 x5 v)
  | (v_fanout v v') => v_fanout (subst_term v5 x5 v) (subst_term v5 x5 v')
end.

Fixpoint subst_context (E5:context) (x5:var) (E_6:context) {struct E_6} : context :=
  match E_6 with
  | (E_var x) => (if eq_var x x5 then E5 else (E_var x))
  | (E_lam x t E) => E_lam x t (if list_mem eq_var x5 (cons x nil) then E else (subst_context E5 x5 E))
  | (E_app E E') => E_app (subst_context E5 x5 E) (subst_context E5 x5 E')
  | E_tt => E_tt 
  | (E_step E E') => E_step (subst_context E5 x5 E) (subst_context E5 x5 E')
  | (E_fanout E E') => E_fanout (subst_context E5 x5 E) (subst_context E5 x5 E')
  | (E_let x y E E') => E_let x y (subst_context E5 x5 E) (if list_mem eq_var x5 (app (cons x nil) (cons y nil)) then E' else (subst_context E5 x5 E'))
end.

(** definitions *)

(** funs toterm *)
Fixpoint toterm (x1:normal) : term:=
  match x1 with
  | N_tt => v_tt
  | (N_fanout N N') => (v_fanout  (toterm N )   (toterm N' ) )
end.


Coercion toterm: normal >-> term.

Definition find (x: var) (Γ: list (var * type)): option type :=
  match List.find (fun '(k, _) => if eq_var x k then true else false) Γ with
  | Some (_, t) => Some t
  | _ => None
  end.

(** definitions *)

(* defns judge_context *)
Inductive JE : linear -> context -> type -> Prop :=    (* defn E *)
 | JE_var : forall (x:var) (t:type),
     JE  (Map.add  x   t    Map.empty  )  (E_var x) t
 | JE_abs : forall (D:linear) (x:var) (t1:type) (E:context) (t2:type),
     JE  (Map.add  x   t1   D )  E t2 ->
     JE D (E_lam x t1 E) (t_prod t1 t2)
 | JE_app : forall (D1 D2:linear) (E1 E2:context) (t2 t1:type),
     JE D1 E1 (t_prod t1 t2) ->
     JE D2 E2 t1 ->
     JE  (Map.merge  D1   D2 )  (E_app E1 E2) t2
 | JE_tt : 
     JE  Map.empty  E_tt t_unit
 | JE_step : forall (D1 D2:linear) (E1 E2:context) (t:type),
     JE D1 E1 t_unit ->
     JE D2 E2 t ->
     JE  (Map.merge  D1   D2 )  (E_step E1 E2) t
 | JE_fanout : forall (D1 D2:linear) (E1 E2:context) (t1 t2:type),
     JE D1 E1 t1 ->
     JE D2 E2 t2 ->
     JE  (Map.merge  D1   D2 )  (E_fanout E1 E2) (t_prod t1 t2)
 | JE_let : forall (D1 D2:linear) (x0 x1:var) (E1 E2:context) (t3 t1 t2:type),
     JE D1 E1 (t_prod t1 t2) ->
     JE  (Map.add  x1   t2    (Map.add  x0   t1   D2 )  )  E2 t3 ->
     JE  (Map.merge  D1   D2 )  (E_let x0 x1 E1 E2) t3.
(** definitions *)

(* defns judge_term *)
Inductive Jv : environment -> term -> type -> Prop :=    (* defn v *)
 | Jv_var : forall (G:environment) (x:var) (t:type),
     find x G = Some t  ->
     Jv G (v_var x) t
 | Jv_tt : forall (G:environment),
     Jv G v_tt t_unit
 | Jv_fanout : forall (G:environment) (v1 v2:term) (t1 t2:type),
     Jv G v1 t1 ->
     Jv G v2 t2 ->
     Jv G (v_fanout v1 v2) (t_prod t1 t2)
 | Jv_fst : forall (G:environment) (v:term) (t1 t2:type),
     Jv G v (t_prod t1 t2) ->
     Jv G (v_fst v) t1
 | Jv_snd : forall (G:environment) (v:term) (t2 t1:type),
     Jv G v (t_prod t1 t2) ->
     Jv G (v_snd v) t2.
(** definitions *)

(* defns big *)
Inductive big : term -> normal -> Prop :=    (* defn big *)
 | big_tt : 
     big v_tt N_tt
 | big_fanout : forall (v1 v2:term) (N1' N2':normal),
     big v1 N1' ->
     big v2 N2' ->
     big  ( (v_fanout v1 v2) )   ( (N_fanout N1' N2') ) 
 | big_fst : forall (v:term) (N1 N2:normal),
     big v (N_fanout N1 N2) ->
     big (v_fst v) N1
 | big_snd : forall (v:term) (N2 N1:normal),
     big v (N_fanout N1 N2) ->
     big (v_snd v) N2.
(** definitions *)

(* defns sat *)
Inductive sat : context -> store -> normal -> Prop :=    (* defn sat *)
 | sat_var : forall (x:var) (N:normal),
     sat (E_var x)  (Map.add  x   N    Map.empty  )  N
 | sat_tt : 
     sat E_tt  Map.empty  N_tt
 | sat_step : forall (E E':context) (S S':store) (N:normal),
     sat E S N_tt ->
     sat E' S' N ->
     sat  ( (E_step E E') )   (Map.merge  S   S' )  N
 | sat_fanout : forall (E E':context) (S S':store) (N N':normal),
     sat E S N ->
     sat E' S' N' ->
     sat  ( (E_fanout E E') )   (Map.merge  S   S' )  (N_fanout N N')
 | sat_let : forall (x y:var) (E E':context) (S S':store) (N2 N0 N1:normal),
     sat E S (N_fanout N0 N1) ->
     sat E'  (Map.add  y   N1    (Map.add  x   N0   S' )  )  N2 ->
     sat  ( (E_let x y E E') )   (Map.merge  S   S' )  N2
 | sat_lam : forall (x:var) (t:type) (E:context) (S:store) (N N':normal),
     sat E  (Map.add  x   N   S )  N' ->
     sat  ( (E_lam x t E) )  S (N_fanout N N')
 | sat_app : forall (E E':context) (S S':store) (N' N:normal),
     sat E S (N_fanout N N') ->
     sat E' S' N ->
     sat (E_app E E')  (Map.merge  S   S' )  N'.
(** definitions *)

(* defns sound *)
Inductive sound : context -> set -> Prop :=    (* defn sound *)
 | sound_nil : forall (E:context),
     sound E  nil 
 | sound_cons : forall (E:context) (X:set) (S:store) (N:normal),
     sound E X ->
     sat E S N ->
     sound E  (cons  (P_with S N)   X ) .


