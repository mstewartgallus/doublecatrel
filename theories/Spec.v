(* generated by Ott 0.32 from: ott/term.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import Ott.ott_list_core.


Require Blech.Assoc.

Definition var : Set := nat.
Lemma eq_var: forall (x y : var), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_var : ott_coq_equality.
Definition sort : Set := nat.
Lemma eq_sort: forall (x y : sort), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_sort : ott_coq_equality.
Definition function : Set := nat.
Lemma eq_function: forall (x y : function), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_function : ott_coq_equality.
Definition relation : Set := nat.
Lemma eq_relation: forall (x y : relation), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_relation : ott_coq_equality.

Inductive type : Set := 
 | t_var (A:sort)
 | t_unit : type
 | t_prod (τ:type) (τ':type).

Inductive context : Set := 
 | E_var (x:var)
 | E_function (f:function) (E:context)
 | E_epsilon (x:var) (c:command)
 | E_tt : context
 | E_fanout (E:context) (E':context)
 | E_match_tt (c:command)
 | E_match_fanout (x:var) (y:var) (c:command)
 | E_dup (E:context)
 | E_del (E:context) (τ:type)
with command : Set := 
 | c_relation (R:relation) (E:context)
 | c_unify (E:context) (E':context) (τ:type)
 | c_false : command
 | c_or (c:command) (c':command).

Definition environment : Set := (Assoc.assoc var type).

Inductive sequent : Set := 
 | H_seq (Γ:environment) (c:command) (c':command).

Inductive use : Set := 
 | u_used : use
 | u_unused : use.

Inductive elim : Set := 
 | V_var (x:var)
 | V_fst (V:elim)
 | V_snd (V:elim).

Definition sorts : Set := (Assoc.assoc var unit).

Definition relations : Set := (Assoc.assoc relation type).

Definition functions : Set := (Assoc.assoc function (type * sort)).

Definition theory : Set := (list sequent).


Definition usage : Set := (Assoc.assoc var use).

Inductive intro : Set := 
 | v_function (f:function) (v:intro)
 | v_tt : intro
 | v_fanout (v:intro) (v':intro)
 | v_neu (V:elim).
Definition subst : Set := (Assoc.assoc var intro).
Lemma eq_type: forall (x y : type), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_type : ott_coq_equality.
Lemma eq_use: forall (x y : use), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_use : ott_coq_equality.
Lemma eq_elim: forall (x y : elim), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_elim : ott_coq_equality.
Lemma eq_intro: forall (x y : intro), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_intro : ott_coq_equality.
(** definitions *)

(** funs eta_expand *)
Fixpoint eta (x1:type) (x2:elim) : intro:=
  match x1,x2 with
  | (t_var A) , V => (v_neu V)
  | t_unit , V => v_tt
  | (t_prod τ1 τ2) , V => (v_fanout  (eta τ1  ( (V_fst V) )  )   (eta τ2  ( (V_snd V) )  ) )
end.

(** definitions *)

(** funs inject_nf *)
Fixpoint inject (x1:intro) : context:=
  match x1 with
  | (v_neu (V_var x)) => (E_var x)
  | v_tt => E_tt
  | (v_fanout v v') => (E_fanout  (inject v )   (inject v' ) )
  | (v_function f v) => (E_function f  (inject v ) )
  | v => E_tt
end.

(** definitions *)

(** funs useallof *)
Fixpoint useall (x1:environment) : usage:=
  match x1 with
  |  nil  =>  nil 
  |  (  (cons (Assoc.maps  x   τ )  Γ )  )  =>  (cons (Assoc.maps  x   u_used )   (useall Γ )  ) 
end.

(** definitions *)

(** funs usenoneof *)
Fixpoint usenone (x1:environment) : usage:=
  match x1 with
  |  nil  =>  nil 
  |  (  (cons (Assoc.maps  x   τ )  Γ )  )  =>  (cons (Assoc.maps  x   u_unused )   (usenone Γ )  ) 
end.

(** definitions *)

(* defns find *)
Inductive mem : var -> type -> environment -> Prop :=    (* defn mem *)
 | mem_eq : forall (x:var) (τ:type) (Γ:environment),
     mem x τ  (cons (Assoc.maps  x   τ )  Γ ) 
 | mem_ne : forall (x:var) (τ:type) (Γ:environment) (y:var) (τ':type),
      ( x  <>  y )  ->
     mem x τ Γ ->
     mem x τ  (cons (Assoc.maps  y   τ' )  Γ ) .
(** definitions *)

(* defns judge_type *)
Inductive Jt : sorts -> type -> Prop :=    (* defn t *)
 | Jt_var : forall (S:sorts) (A:sort),
     Assoc.find A S = Some tt  ->
     Jt S (t_var A)
 | Jt_unit : forall (S:sorts),
     Jt S t_unit
 | Jt_prod : forall (S:sorts) (τ τ':type),
     Jt S τ ->
     Jt S τ' ->
     Jt S (t_prod τ τ').
(** definitions *)

(* defns judge_functions *)
Inductive Jf : sorts -> functions -> Prop :=    (* defn f *)
 | Jf_nil : forall (S:sorts),
     Jf S  nil 
 | Jf_cons : forall (S:sorts) (FS:functions) (f:function) (τ:type) (A:sort),
     Assoc.find A S = Some tt  ->
     Jt S τ ->
     Jf S FS ->
     Jf S  (cons (Assoc.maps  f  ( τ ,  A ))  FS ) .
(** definitions *)

(* defns judge_relations *)
Inductive JR : sorts -> relations -> Prop :=    (* defn R *)
 | JR_nil : forall (S:sorts),
     JR S  nil 
 | JR_cons : forall (S:sorts) (RS:relations) (R:relation) (τ:type),
     Jt S τ ->
     JR S RS ->
     JR S  (cons (Assoc.maps  R   τ )  RS ) .
(** definitions *)

(* defns judge_term *)
Inductive JV : sorts -> functions -> environment -> elim -> type -> Prop :=    (* defn V *)
 | JV_var : forall (S:sorts) (FS:functions) (Γ:environment) (x:var) (τ:type),
     mem x τ Γ ->
     JV S FS Γ (V_var x) τ
 | JV_fst : forall (S:sorts) (FS:functions) (Γ:environment) (V:elim) (τ1 τ2:type),
     JV S FS Γ V (t_prod τ1 τ2) ->
     JV S FS Γ (V_fst V) τ1
 | JV_snd : forall (S:sorts) (FS:functions) (Γ:environment) (V:elim) (τ2 τ1:type),
     JV S FS Γ V (t_prod τ1 τ2) ->
     JV S FS Γ (V_snd V) τ2
with Jv : sorts -> functions -> environment -> intro -> type -> Prop :=    (* defn v *)
 | Jv_function : forall (S:sorts) (FS:functions) (Γ:environment) (f:function) (v:intro) (A:sort) (τ:type),
     Assoc.find f FS = Some (τ, A)  ->
     Jv S FS Γ v τ ->
     Jv S FS Γ (v_function f v) (t_var A)
 | Jv_tt : forall (S:sorts) (FS:functions) (Γ:environment),
     Jv S FS Γ v_tt t_unit
 | Jv_fanout : forall (S:sorts) (FS:functions) (Γ:environment) (v1 v2:intro) (τ1 τ2:type),
     Jv S FS Γ v1 τ1 ->
     Jv S FS Γ v2 τ2 ->
     Jv S FS Γ (v_fanout v1 v2) (t_prod τ1 τ2)
 | Jv_neu : forall (S:sorts) (FS:functions) (Γ:environment) (V:elim) (A:sort),
     JV S FS Γ V (t_var A) ->
     Jv S FS Γ (v_neu V) (t_var A).
(** definitions *)

(* defns judge_subst *)
Inductive Jp : sorts -> functions -> subst -> environment -> environment -> Prop :=    (* defn p *)
 | Jp_bang : forall (S:sorts) (FS:functions) (Γ:environment),
     Jp S FS  nil  Γ  nil 
 | Jp_cut : forall (S:sorts) (FS:functions) (ρ:subst) (x:var) (v:intro) (Γ1 Γ2:environment) (τ:type),
     Jv S FS Γ1 v τ ->
     Jp S FS ρ Γ1 Γ2 ->
     Jp S FS  (cons (Assoc.maps  x   v )  ρ )  Γ1  (cons (Assoc.maps  x   τ )  Γ2 ) .
(** definitions *)

(* defns bigV *)
Inductive bigV : subst -> elim -> intro -> Prop :=    (* defn bigV *)
 | bigV_var : forall (ρ:subst) (x:var) (v:intro),
     Assoc.find x ρ = Some v  ->
     bigV ρ (V_var x) v
 | bigV_fst : forall (ρ:subst) (V:elim) (v1 v2:intro),
     bigV ρ V (v_fanout v1 v2) ->
     bigV ρ (V_fst V) v1
 | bigV_snd : forall (ρ:subst) (V:elim) (v2 v1:intro),
     bigV ρ V (v_fanout v1 v2) ->
     bigV ρ (V_snd V) v2.
(** definitions *)

(* defns bigv *)
Inductive bigv : subst -> intro -> intro -> Prop :=    (* defn bigv *)
 | bigv_function : forall (ρ:subst) (f:function) (v v':intro),
     bigv ρ v v' ->
     bigv ρ (v_function f v) (v_function f v')
 | bigv_tt : forall (ρ:subst),
     bigv ρ v_tt v_tt
 | bigv_fanout : forall (ρ:subst) (v1 v2 v1' v2':intro),
     bigv ρ v1 v1' ->
     bigv ρ v2 v2' ->
     bigv ρ (v_fanout v1 v2) (v_fanout v1' v2')
 | bigv_neu : forall (ρ:subst) (V:elim) (v:intro),
     bigV ρ V v ->
     bigv ρ (v_neu V) v.
(** definitions *)

(* defns lfind *)
Inductive lmem : var -> usage -> usage -> Prop :=    (* defn lmem *)
 | lmem_eq : forall (x:var) (Δ:usage),
     lmem x  (cons (Assoc.maps  x   u_unused )  Δ )   (cons (Assoc.maps  x   u_used )  Δ ) 
 | lmem_ne : forall (x:var) (Δ:usage) (y:var) (u:use) (Δ':usage),
      ( x  <>  y )  ->
     lmem x Δ Δ' ->
     lmem x  (cons (Assoc.maps  y   u )  Δ )   (cons (Assoc.maps  y   u )  Δ' ) .
(** definitions *)

(* defns scope *)
Inductive se : usage -> command -> usage -> Prop :=    (* defn se *)
 | se_relation : forall (Δ:usage) (R:relation) (E:context) (Δ':usage),
     sE Δ E Δ' ->
     se Δ (c_relation R E) Δ'
 | se_unify : forall (Δ1:usage) (E E':context) (τ:type) (Δ3 Δ2:usage),
     sE Δ1 E Δ2 ->
     sE Δ2 E' Δ3 ->
     se Δ1 (c_unify E E' τ) Δ3
 | se_false : forall (Δ:usage),
     se Δ c_false Δ
 | se_or : forall (Δ1:usage) (c c':command) (Δ2:usage),
     se Δ1 c Δ2 ->
     se Δ1 c' Δ2 ->
     se Δ1 (c_or c c') Δ2
with sE : usage -> context -> usage -> Prop :=    (* defn sE *)
 | sE_var : forall (Δ:usage) (x:var) (Δ':usage),
     lmem x Δ Δ' ->
     sE Δ (E_var x) Δ'
 | sE_function : forall (Δ:usage) (f:function) (E:context) (Δ':usage),
     sE Δ E Δ' ->
     sE Δ (E_function f E) Δ'
 | sE_epsilon : forall (Δ:usage) (x:var) (c:command) (Δ':usage),
     se  (cons (Assoc.maps  x   u_unused )  Δ )  c  (cons (Assoc.maps  x   u_used )  Δ' )  ->
     sE Δ (E_epsilon x c) Δ'
 | sE_tt : forall (Δ:usage),
     sE Δ E_tt Δ
 | sE_fanout : forall (Δ1:usage) (E1 E2:context) (Δ3 Δ2:usage),
     sE Δ1 E1 Δ2 ->
     sE Δ2 E2 Δ3 ->
     sE Δ1 (E_fanout E1 E2) Δ3
 | sE_match_tt : forall (Δ1:usage) (c:command) (Δ2:usage),
     se Δ1 c Δ2 ->
     sE Δ1 (E_match_tt c) Δ2
 | sE_match_fanout : forall (Δ1:usage) (x y:var) (c:command) (Δ2:usage),
     se  (cons (Assoc.maps  y   u_unused )   (cons (Assoc.maps  x   u_unused )  Δ1 )  )  c  (cons (Assoc.maps  y   u_used )   (cons (Assoc.maps  x   u_used )  Δ2 )  )  ->
     sE Δ1 (E_match_fanout x y c) Δ2
 | sE_dup : forall (Δ1:usage) (E:context) (Δ2:usage),
     sE Δ1 E Δ2 ->
     sE Δ1 (E_dup E) Δ2
 | sE_del : forall (Δ1:usage) (E:context) (τ:type) (Δ2:usage),
     sE Δ1 E Δ2 ->
     sE Δ1 (E_del E τ) Δ2.
(** definitions *)

(* defns judge_context *)
Inductive infer : sorts -> functions -> relations -> environment -> command -> Prop :=    (* defn infer *)
 | infer_relation : forall (S:sorts) (FS:functions) (RS:relations) (Γ:environment) (R:relation) (E:context) (τ:type),
     Assoc.find R RS = Some τ  ->
     check S FS RS Γ E τ ->
     infer S FS RS Γ (c_relation R E)
 | infer_unify : forall (S:sorts) (FS:functions) (RS:relations) (Γ:environment) (E E':context) (τ:type),
     check S FS RS Γ E τ ->
     check S FS RS Γ E' τ ->
     infer S FS RS Γ (c_unify E E' τ)
 | infer_false : forall (S:sorts) (FS:functions) (RS:relations) (Γ:environment),
     infer S FS RS Γ c_false
 | infer_or : forall (S:sorts) (FS:functions) (RS:relations) (Γ:environment) (c c':command),
     infer S FS RS Γ c ->
     infer S FS RS Γ c' ->
     infer S FS RS Γ (c_or c c')
with check : sorts -> functions -> relations -> environment -> context -> type -> Prop :=    (* defn check *)
 | check_var : forall (S:sorts) (FS:functions) (RS:relations) (Γ:environment) (x:var) (τ:type),
     Assoc.find x Γ = Some τ  ->
     check S FS RS Γ (E_var x) τ
 | check_function : forall (S:sorts) (FS:functions) (RS:relations) (Γ:environment) (f:function) (E:context) (A:sort) (τ:type),
     Assoc.find f FS = Some (τ, A)  ->
     check S FS RS Γ E τ ->
     check S FS RS Γ (E_function f E) (t_var A)
 | check_epsilon : forall (S:sorts) (FS:functions) (RS:relations) (Γ:environment) (x:var) (c:command) (A:sort),
     Assoc.find A S = Some tt  ->
     infer S FS RS  (cons (Assoc.maps  x   (t_var A) )  Γ )  c ->
     check S FS RS Γ (E_epsilon x c) (t_var A)
 | check_tt : forall (S:sorts) (FS:functions) (RS:relations) (Γ:environment),
     check S FS RS Γ E_tt t_unit
 | check_fanout : forall (S:sorts) (FS:functions) (RS:relations) (Γ:environment) (E1 E2:context) (τ1 τ2:type),
     check S FS RS Γ E1 τ1 ->
     check S FS RS Γ E2 τ2 ->
     check S FS RS Γ (E_fanout E1 E2) (t_prod τ1 τ2)
 | check_match_tt : forall (S:sorts) (FS:functions) (RS:relations) (Γ:environment) (c:command),
     infer S FS RS Γ c ->
     check S FS RS Γ (E_match_tt c) t_unit
 | check_match_fanout : forall (S:sorts) (FS:functions) (RS:relations) (Γ:environment) (x y:var) (c:command) (τ1 τ2:type),
     infer S FS RS  (cons (Assoc.maps  y   τ2 )   (cons (Assoc.maps  x   τ1 )  Γ )  )  c ->
     check S FS RS Γ (E_match_fanout x y c) (t_prod τ1 τ2)
 | check_dup : forall (S:sorts) (FS:functions) (RS:relations) (Γ:environment) (E:context) (τ:type),
     check S FS RS Γ E τ ->
     check S FS RS Γ (E_dup E) (t_prod τ τ)
 | check_del : forall (S:sorts) (FS:functions) (RS:relations) (Γ:environment) (E:context) (τ:type),
     check S FS RS Γ E τ ->
     check S FS RS Γ (E_del E τ) t_unit.
(** definitions *)

(* defns judge_sequent *)
Inductive JH : sorts -> functions -> relations -> sequent -> Prop :=    (* defn H *)
 | JH_sequent : forall (S:sorts) (FS:functions) (RS:relations) (Γ:environment) (c c':command),
     infer S FS RS Γ c ->
     infer S FS RS Γ c' ->
     se  (usenone Γ )  c  (useall Γ )  ->
     se  (usenone Γ )  c'  (useall Γ )  ->
     JH S FS RS (H_seq Γ c c').
(** definitions *)

(* defns judge_theory *)
Inductive JT : sorts -> functions -> relations -> theory -> Prop :=    (* defn T *)
 | JT_nil : forall (S:sorts) (FS:functions) (RS:relations),
     JT S FS RS  nil 
 | JT_cons : forall (S:sorts) (FS:functions) (RS:relations) (T:theory) (H:sequent),
     JH S FS RS H ->
     JT S FS RS T ->
     JT S FS RS  (cons  H   T ) .
(** definitions *)

(* defns pfind *)
Inductive pmem : var -> intro -> subst -> subst -> Prop :=    (* defn pmem *)
 | pmem_eq : forall (x:var) (v:intro) (ρ:subst),
     pmem x v  (cons (Assoc.maps  x   v )  ρ )   (cons (Assoc.maps  x   v_tt )  ρ ) 
 | pmem_ne : forall (x:var) (v:intro) (ρ:subst) (y:var) (v':intro) (ρ':subst),
      ( x  <>  y )  ->
     pmem x v ρ ρ' ->
     pmem x v  (cons (Assoc.maps  y   v' )  ρ )   (cons (Assoc.maps  y   v' )  ρ' ) .
(** definitions *)

(* defns sat *)
Inductive produces : theory -> subst -> command -> subst -> Prop :=    (* defn produces *)
 | produces_unify : forall (T:theory) (ρ1:subst) (E E':context) (τ:type) (ρ3:subst) (v:intro) (ρ2:subst),
     accepts T ρ1 E v ρ2 ->
     accepts T ρ2 E' v ρ3 ->
     produces T ρ1 (c_unify E E' τ) ρ3
 | produces_or_inl : forall (T:theory) (ρ:subst) (c c':command) (ρ':subst),
     produces T ρ c ρ' ->
     produces T ρ (c_or c c') ρ'
 | produces_or_inr : forall (T:theory) (ρ:subst) (c c':command) (ρ':subst),
     produces T ρ c' ρ' ->
     produces T ρ (c_or c c') ρ'
with accepts : theory -> subst -> context -> intro -> subst -> Prop :=    (* defn accepts *)
 | accepts_var : forall (T:theory) (ρ:subst) (x:var) (v:intro) (ρ':subst),
     pmem x v ρ ρ' ->
     accepts T ρ (E_var x) v ρ'
 | accepts_function : forall (T:theory) (ρ:subst) (f:function) (E:context) (v:intro) (ρ':subst),
     accepts T ρ E v ρ' ->
     accepts T ρ (E_function f E) (v_function f v) ρ'
 | accepts_tt : forall (T:theory) (ρ:subst),
     accepts T ρ E_tt v_tt ρ
 | accepts_fanout : forall (T:theory) (ρ1:subst) (E E':context) (v v':intro) (ρ3 ρ2:subst),
     accepts T ρ1 E v ρ2 ->
     accepts T ρ2 E' v' ρ3 ->
     accepts T ρ1  ( (E_fanout E E') )  (v_fanout v v') ρ3
 | accepts_match_tt : forall (T:theory) (ρ1:subst) (c:command) (ρ2:subst),
     produces T ρ1 c ρ2 ->
     accepts T ρ1 (E_match_tt c) v_tt ρ2
 | accepts_match_fanout : forall (T:theory) (ρ1:subst) (x y:var) (c:command) (v0 v1:intro) (ρ2:subst) (v0' v1':intro),
     produces T  (cons (Assoc.maps  y   v1 )   (cons (Assoc.maps  x   v0 )  ρ1 )  )  c  (cons (Assoc.maps  y   v1' )   (cons (Assoc.maps  x   v0' )  ρ2 )  )  ->
     accepts T ρ1 (E_match_fanout x y c) (v_fanout v0 v1) ρ2
 | accepts_del : forall (T:theory) (ρ1:subst) (E:context) (τ:type) (ρ2:subst) (v:intro),
     accepts T ρ1 E v ρ2 ->
     accepts T ρ1 (E_del E τ) v_tt ρ2
 | accepts_dup : forall (T:theory) (ρ1:subst) (E:context) (v:intro) (ρ2:subst),
     accepts T ρ1 E v ρ2 ->
     accepts T ρ1 (E_dup E) (v_fanout v v) ρ2
 | accepts_epsilon : forall (T:theory) (ρ1:subst) (x:var) (c:command) (v:intro) (ρ2:subst) (v':intro),
     produces T  (cons (Assoc.maps  x   v )  ρ1 )  c  (cons (Assoc.maps  x   v' )  ρ2 )  ->
     accepts T ρ1  ( (E_epsilon x c) )  v ρ2.


