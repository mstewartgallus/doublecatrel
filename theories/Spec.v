(* generated by Ott 0.31 from: ott/test.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import Ott.ott_list_core.


Require Blech.Map.

Definition var : Set := nat.
Lemma eq_var: forall (x y : var), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_var : ott_coq_equality.
Definition index : Set := nat.

Inductive term : Set := 
 | v_tt : term
 | v_fst (v:term)
 | v_snd (v:term)
 | v_fanout (v:term) (v':term).

Inductive type : Set := 
 | t_unit : type
 | t_prod (t:type) (t':type).

Definition satenv : Type := Map.map term.

Inductive context : Set := 
 | E_var (x:var)
 | E_all (x:var) (t:type) (E:context)
 | E_app (E:context) (E':context).

Definition environment : Type := Map.map type.

Inductive term_ctx : Set := 
 | V_fst : term_ctx
 | V_snd : term_ctx
 | V_fanout_l (v:term)
 | V_fanout_r (v:term).

Inductive context_ctx : Set := 
 | e_forall (x:var) (t:type)
 | e_app_l (E:context)
 | e_app_r (E:context).
(** library functions *)
Fixpoint list_mem A (eq:forall a b:A,{a=b}+{a<>b}) (x:A) (l:list A) {struct l} : bool :=
  match l with
  | nil => false
  | cons h t => if eq h x then true else list_mem A eq x t
end.
Arguments list_mem [A] _ _ _.


(** substitutions *)
Fixpoint subst_context (E5:context) (x5:var) (E_6:context) {struct E_6} : context :=
  match E_6 with
  | (E_var x) => (if eq_var x x5 then E5 else (E_var x))
  | (E_all x t E) => E_all x t (if list_mem eq_var x5 (cons x nil) then E else (subst_context E5 x5 E))
  | (E_app E E') => E_app (subst_context E5 x5 E) (subst_context E5 x5 E')
end.

Definition subst_context_ctx (E5:context) (x5:var) (e5:context_ctx) : context_ctx :=
  match e5 with
  | (e_forall x t) => e_forall x t
  | (e_app_l E) => e_app_l (subst_context E5 x5 E)
  | (e_app_r E) => e_app_r (subst_context E5 x5 E)
end.


(** context application *)
Definition appctx_term_ctx_term (term_ctx5:term_ctx) (term5:term) : term :=
  match term_ctx5 with
  | V_fst => (v_fst term5)
  | V_snd => (v_snd term5)
  | (V_fanout_l v) => (v_fanout v term5)
  | (V_fanout_r v) => (v_fanout term5 v)
end.

Definition appctx_context_ctx_context (context_ctx5:context_ctx) (context5:context) : context :=
  match context_ctx5 with
  | (e_forall x t) => (E_all x t context5)
  | (e_app_l E) => (E_app E context5)
  | (e_app_r E) => (E_app context5 E)
end.


(** subrules *)
Fixpoint is_term_norm_of_term (v5:term) : bool :=
  match v5 with
  | v_tt => (true)
  | (v_fst v) => false
  | (v_snd v) => false
  | (v_fanout v v') => ((is_term_norm_of_term v) && (is_term_norm_of_term v'))
end.

Definition is_context_whnf_of_context (E5:context) : bool :=
  match E5 with
  | (E_var x) => false
  | (E_all x t E) => (true)
  | (E_app E E') => false
end.

(** library functions *)
Fixpoint list_minus A (eq:forall a b:A,{a=b}+{a<>b}) (l1:list A) (l2:list A) {struct l1} : list A :=
  match l1 with
  | nil => nil
  | cons h t => if (list_mem (A:=A) eq h l2) then list_minus A eq t l2 else cons h (list_minus A eq t l2)
end.
Arguments list_minus [A] _ _ _.


(** free variables *)
Fixpoint fv_context (E5:context) : list var :=
  match E5 with
  | (E_var x) => (cons x nil)
  | (E_all x t E) => ((list_minus eq_var (fv_context E) (cons x nil)))
  | (E_app E E') => (app (fv_context E) (fv_context E'))
end.

Definition fv_context_ctx (e5:context_ctx) : list var :=
  match e5 with
  | (e_forall x t) => nil
  | (e_app_l E) => ((fv_context E))
  | (e_app_r E) => ((fv_context E))
end.

(** definitions *)

(* defns judge *)
Inductive JE : environment -> context -> type -> Prop :=    (* defn E *)
 | JE_var : forall (x:var) (t:type),
     JE  (Map.add  x   t    Map.empty  )  (E_var x) t
 | JE_abs : forall (G:environment) (x:var) (t1:type) (E:context) (t2:type),
     JE  (Map.add  x   t1   G )  E t2 ->
     JE G (E_all x t1 E) (t_prod t1 t2)
 | JE_app : forall (G1 G2:environment) (E1 E2:context) (t2 t1:type),
     JE G1 E1 (t_prod t1 t2) ->
     JE G2 E2 t1 ->
     JE  (Map.merge  G1   G2 )  (E_app E1 E2) t2
with Jv : term -> type -> Prop :=    (* defn v *)
 | Jv_tt : 
     Jv v_tt t_unit
 | Jv_fanout : forall (v1 v2:term) (t1 t2:type),
     Jv v1 t1 ->
     Jv v2 t2 ->
     Jv (v_fanout v1 v2) (t_prod t1 t2)
 | Jv_fst : forall (v:term) (t1 t2:type),
     Jv v (t_prod t1 t2) ->
     Jv (v_fst v) t1
 | Jv_snd : forall (v:term) (t2 t1:type),
     Jv v (t_prod t1 t2) ->
     Jv (v_snd v) t2
with Jsat : satenv -> context -> term -> Prop :=    (* defn sat *)
 | Jsat_var : forall (x:var) (v:term),
     Jsat  (Map.add  x   v    Map.empty  )  (E_var x) v
 | Jsat_abs : forall (D:satenv) (x:var) (t:type) (E:context) (v0 v1:term),
     Jv v0 t ->
     Jsat  (Map.add  x   v0   D )  E v1 ->
     Jsat D  ( (E_all x t E) )  (v_fanout v0 v1)
 | Jsat_app : forall (D D':satenv) (E0 E1:context) (v:term),
     Jsat D E0 v ->
     Jsat D' E1 (v_fst v) ->
     Jsat  (Map.merge  D   D' )   ( (E_app E0 E1) )  (v_snd v).
(** definitions *)

(* defns eval *)
Inductive step_E : context -> context -> Prop :=    (* defn step_E *)
 | stepE_beta : forall (x:var) (t:type) (E E':context),
     step_E (E_app  ( (E_all x t E) )  E')  (subst_context  E'   x   E ) 
 | stepE_ctx : forall (e:context_ctx) (E E':context),
     step_E E E' ->
     step_E  (appctx_context_ctx_context  e   E )   (appctx_context_ctx_context  e   E' ) 
with step_v : term -> term -> Prop :=    (* defn step_v *)
 | stepv_beta1 : forall (v1 v2:term),
     step_v (v_fst  ( (v_fanout v1 v2) ) ) v1
 | stepv_beta2 : forall (v1 v2:term),
     step_v (v_snd  ( (v_fanout v1 v2) ) ) v2
 | stepv_ctx : forall (V:term_ctx) (v v':term),
     step_v v v' ->
     step_v  (appctx_term_ctx_term  V   v )   (appctx_term_ctx_term  V   v' ) 
with multi_v : term -> term -> Prop :=    (* defn multi_v *)
 | multiv_id : forall (v:term),
     multi_v v v
 | multiv_then : forall (v1 v3 v2:term),
     step_v v1 v2 ->
     multi_v v2 v3 ->
     multi_v v1 v3
with multi_E : context -> context -> Prop :=    (* defn multi_E *)
 | multiE_id : forall (E:context),
     multi_E E E
 | multiE_then : forall (E1 E3 E2:context),
     step_E E1 E2 ->
     multi_E E2 E3 ->
     multi_E E1 E3.


